<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Synth Master Sync</title>
    <style>
        body { margin: 0; overflow: hidden; background: #080808; touch-action: none; color: white; font-family: monospace; }
        
        /* --- コントロールパネル --- */
        #controls {
            position: fixed; bottom: 0; left: 0; width: 100%; height: 280px; 
            background: linear-gradient(transparent, rgba(0,0,0,0.95) 15%);
            display: flex; flex-direction: row; justify-content: center; align-items: center;
            padding-bottom: 20px; z-index: 50; gap: 15px; box-sizing: border-box;
            touch-action: pan-x; -webkit-overflow-scrolling: touch;
        }
        #controls * { touch-action: pan-x; }

        .panel-section {
            display: flex; flex-direction: column; align-items: center;
            background: rgba(10, 10, 10, 0.85); border: 1px solid #333; border-radius: 6px;
            padding: 10px;
            backdrop-filter: blur(10px); width: 260px; height: 210px;
            justify-content: flex-start; box-shadow: 0 4px 15px rgba(0,0,0,0.6);
            flex-shrink: 0; position: relative; transition: transform 0.2s, box-shadow 0.2s;
        }
        .panel-section:hover { border-color: #555; box-shadow: 0 0 20px rgba(0, 255, 204, 0.1); }
        .panel-section::after {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 2px;
            background: linear-gradient(90deg, transparent, #00ffcc, transparent); opacity: 0.6;
        }
        
        .label { font-size: 11px; color: #00ffcc; margin-bottom: 8px; letter-spacing: 2px; text-shadow: 0 0 8px rgba(0,255,204,0.6); font-weight: bold; text-transform: uppercase; pointer-events: none; }

        #wave-canvas, #eq-canvas, #adsr-canvas { background: rgba(0, 0, 0, 0.5); border: 1px solid #444; border-radius: 4px; box-shadow: inset 0 0 15px rgba(0,0,0,0.8); width: 240px; }
        
        #wave-canvas { height: 90px; cursor: crosshair; touch-action: none; user-select: none; }
        #eq-canvas { height: 100px; cursor: default; touch-action: none; }
        #adsr-canvas { height: 70px; }

        .eq-values { font-size: 10px; color: #888; width: 100%; text-align: center; margin-top: 5px; font-family: monospace; pointer-events: none; }
        .mixer-container { display: flex; gap: 30px; height: 100%; align-items: center; justify-content: center; }
        #adsr-container { display: flex; flex-direction: column; align-items: center; width: 100%; }
        .sliders { display: flex; gap: 10px; width: 100%; justify-content: space-between; margin-top: 5px; }
        .slider-group { display: flex; flex-direction: column; align-items: center; position: relative; }
        
        input[type=range].vertical {
            -webkit-appearance: none; appearance: none; width: 30px; height: 100px;
            background: transparent; outline: none; writing-mode: bt-lr; -webkit-appearance: slider-vertical;
            cursor: pointer; position: relative; z-index: 2;
            background: linear-gradient(to right, transparent 13px, #222 13px, #222 17px, transparent 17px);
            touch-action: pan-x; 
        }
        input[type=range].vertical::-webkit-slider-thumb {
            -webkit-appearance: none; width: 28px; height: 14px; background: #000; 
            border: 1px solid #00ffcc; border-radius: 2px; box-shadow: 0 0 8px rgba(0,255,204,0.4);
            margin-top: 0; position: relative; z-index: 3;
        }
        .param-label { font-size: 10px; color: #666; margin-top: 6px; font-weight: bold; letter-spacing: 1px; pointer-events: none; }

        .btn-group { display: flex; gap: 10px; margin-top: 10px; }
        button {
            background: rgba(0,0,0,0.6); border: 1px solid #333; border-bottom: 2px solid #333;
            color: #00ffcc; font-size: 10px; padding: 6px 14px; cursor: pointer; border-radius: 2px;
            transition: all 0.1s; font-family: monospace; text-shadow: 0 0 5px rgba(0,255,204,0.3);
            touch-action: pan-x;
        }
        button:hover { background: rgba(0, 255, 204, 0.1); border-color: #00ffcc; }
        button.active { background: #00ffcc; color: #000; border-color: #00ffcc; box-shadow: 0 0 15px rgba(0,255,204,0.6); text-shadow: none; font-weight: bold; }

        .scale-grid { 
            display: grid; 
            grid-template-columns: 1fr 1fr; 
            gap: 4px; 
            width: 100%; 
            margin-top: 5px; 
            height: 100%; 
            overflow-y: auto; 
            align-content: start;
        }
        .scale-btn { 
            padding: 8px 4px; 
            font-size: 9px; 
            text-align: left; 
            width: 100%; 
            white-space: nowrap; 
            overflow: hidden; 
            text-overflow: ellipsis; 
            touch-action: pan-x; 
            border: 1px solid #333; 
            background: rgba(0,0,0,0.3); 
            box-sizing: border-box; 
        }
        .scale-btn.active { border-color: #00ffcc; background: rgba(0,255,204,0.2); color: white; box-shadow: 0 0 8px rgba(0,255,204,0.3); }

        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.92); z-index: 999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            cursor: pointer; letter-spacing: 3px;
        }
        #overlay span { margin-top: 15px; font-size: 10px; color: #888; letter-spacing: 1px; }

        @media (min-width: 1100px) { #controls { justify-content: center; gap: 20px; } }
        @media (max-width: 1099px) { 
            #controls { justify-content: flex-start; overflow-x: auto; padding: 10px 20px 30px 20px; scroll-snap-type: x mandatory; } 
            #controls::-webkit-scrollbar { display: none; } 
            .panel-section { scroll-snap-align: center; margin-right: 5px; } 
        }
    </style>
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    
    <div id="overlay">
        <div>TAP TO START</div>
        <span>PLAY INSIDE THE SQUARE</span>
    </div>

    <div id="controls">
        <div class="panel-section">
            <div class="label">1. WAVEFORM</div>
            <canvas id="wave-canvas" width="240" height="90"></canvas>
            <div class="btn-group">
                <button id="reset-btn">RESET</button>
                <button id="drone-btn" class="active">AMBIENT: ON</button>
            </div>
        </div>

        <div class="panel-section">
            <div class="label">2. EQ & SPECTRUM</div>
            <div id="eq-container" style="width:100%; height:100%; display:flex; flex-direction:column; align-items:center; justify-content:center;">
                <canvas id="eq-canvas" width="240" height="100"></canvas>
                <div class="eq-values" id="eq-readout">DRAG POINTS</div>
            </div>
        </div>

        <div class="panel-section">
            <div class="label">3. MIXER</div>
            <div class="mixer-container">
                <div class="slider-group"><input type="range" class="vertical" id="vol-synth" min="-60" max="0" step="1" value="-6"><span class="param-label">SYNTH</span></div>
                <div class="slider-group"><input type="range" class="vertical" id="vol-drone" min="-60" max="0" step="1" value="-5"><span class="param-label">DRONE</span></div>
            </div>
        </div>

        <div class="panel-section">
            <div class="label">4. ENVELOPE</div>
            <div id="adsr-container">
                <canvas id="adsr-canvas" width="240" height="70"></canvas>
                <div class="sliders">
                    <div class="slider-group"><input type="range" class="vertical" id="adsr-a" min="0.01" max="2.0" step="0.01" value="0.1"><span class="param-label">A</span></div>
                    <div class="slider-group"><input type="range" class="vertical" id="adsr-d" min="0.1" max="2.0" step="0.01" value="0.2"><span class="param-label">D</span></div>
                    <div class="slider-group"><input type="range" class="vertical" id="adsr-s" min="0" max="1.0" step="0.01" value="0.5"><span class="param-label">S</span></div>
                    <div class="slider-group"><input type="range" class="vertical" id="adsr-r" min="0.1" max="5.0" step="0.1" value="1.5"><span class="param-label">R</span></div>
                </div>
            </div>
        </div>

        <div class="panel-section">
            <div class="label">5. SCALE (MOOD)</div>
            <div class="scale-grid">
                <button class="scale-btn active" data-scale="MINOR_PENTATONIC">MINOR PENTATONIC</button>
                <button class="scale-btn" data-scale="MAJOR">MAJOR (BRIGHT)</button>
                <button class="scale-btn" data-scale="MINOR">MINOR (DARK)</button>
                <button class="scale-btn" data-scale="DORIAN">DORIAN (COOL)</button>
                <button class="scale-btn" data-scale="LYDIAN">LYDIAN (ETHEREAL)</button>
                <button class="scale-btn" data-scale="RYUKYU">RYUKYU (ISLAND)</button>
                <button class="scale-btn" data-scale="MIYAKOBUSHI">MIYAKOBUSHI</button>
                <button class="scale-btn" data-scale="WHOLE_TONE">WHOLE TONE</button>
            </div>
        </div>
    </div>

    <script>
        const socket = io();
        let isStarted = false;
        
        let synth, limiter, chorus, reverb, fft; // ★FFT追加
        let eqLow, eqMid, eqHigh; 
        let droneSynth;
        let isDroneOn = true;

        let playAreaSize = 0;
        let playAreaMesh;
        let playAreaOffsetY = 0; 
        
        let prevNotePos = null;

        // --- Visuals ---
        const scene = new THREE.Scene();
        const width = window.innerWidth;
        const height = window.innerHeight;
        const camera = new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, 1, 1000);
        camera.position.z = 10;
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(width, height);
        renderer.domElement.id = 'main-canvas';
        document.body.appendChild(renderer.domElement);

        function updateLayout() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            const controlsEl = document.getElementById('controls');
            const controlsHeight = controlsEl ? controlsEl.offsetHeight : 0;
            const availableHeight = h - controlsHeight;
            playAreaSize = Math.min(w, availableHeight) * 0.9;
            playAreaOffsetY = controlsHeight / 2;
            camera.left = w / -2; camera.right = w / 2;
            camera.top = h / 2; camera.bottom = h / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(w, h);
            if (playAreaMesh) scene.remove(playAreaMesh);
            const borderGeo = new THREE.EdgesGeometry(new THREE.PlaneGeometry(playAreaSize, playAreaSize));
            const borderMat = new THREE.LineBasicMaterial({ color: 0x444444 });
            playAreaMesh = new THREE.LineSegments(borderGeo, borderMat);
            playAreaMesh.position.y = playAreaOffsetY;
            scene.add(playAreaMesh);
            resizeCanvases();
        }
        function resizeCanvases() {
            const wCanvas = document.getElementById('wave-canvas');
            const eCanvas = document.getElementById('eq-canvas');
            const aCanvas = document.getElementById('adsr-canvas');
            wCanvas.width = 240; wCanvas.height = 90;
            eCanvas.width = 240; eCanvas.height = 100;
            aCanvas.width = 240; aCanvas.height = 70;
            drawWave(waveBuffer); 
            // EQはアニメーションループで描画するのでここでは一旦呼ばない
            drawADSRVisual();
        }
        window.addEventListener('resize', updateLayout);
        setTimeout(updateLayout, 100);

        const visualObjects = []; 
        function animate() {
            requestAnimationFrame(animate);

            // ★スペクトラムとEQを毎フレーム描画
            if(isStarted) drawEQ();

            const now = Date.now();
            for (let i = visualObjects.length - 1; i >= 0; i--) {
                const obj = visualObjects[i];
                const progress = (now - obj.startTime) / (obj.duration * 1000);
                if (progress >= 1) {
                    scene.remove(obj.mesh);
                    visualObjects.splice(i, 1);
                } else {
                    if(obj.type === 'ring') {
                        const scale = (playAreaSize * 0.02) + (progress * playAreaSize * 0.4);
                        obj.mesh.scale.set(scale, scale, 1);
                        obj.mesh.material.opacity = (1 - Math.pow(progress, 2)) * 0.3;
                    } else if (obj.type === 'line') {
                        obj.mesh.material.opacity = (1 - progress) * 0.2;
                    }
                }
            }
            renderer.render(scene, camera);
        }
        animate();

        // --- Audio ---
        let localADSR = { attack: 0.1, decay: 0.2, sustain: 0.5, release: 1.5 };
        let localMixer = { synth: -6, drone: -5 }; 
        let localEQ = { low: {freq:100, gain:0}, mid: {freq:1000, gain:0}, high: {freq:5000, gain:0} };

        const NOTE_NAMES = ["C", "Db", "D", "Eb", "E", "F", "F#", "G", "Ab", "A", "Bb", "B"];
        function generateScale(intervals) {
            const notes = [];
            for (let oct = 2; oct <= 7; oct++) {
                for (let i = 0; i < 12; i++) {
                    if (intervals.includes(i)) {
                        if (oct === 7 && i > 0) break;
                        notes.push(NOTE_NAMES[i] + oct);
                    }
                }
            }
            return notes;
        }

        const SCALE_DEFINITIONS = {
            "MINOR_PENTATONIC": [0, 3, 5, 7, 10], 
            "MAJOR":            [0, 2, 4, 5, 7, 9, 11],
            "MINOR":            [0, 2, 3, 5, 7, 8, 10],
            "DORIAN":           [0, 2, 3, 5, 7, 9, 10],
            "LYDIAN":           [0, 2, 4, 6, 7, 9, 11],
            "RYUKYU":           [0, 4, 5, 7, 11],
            "MIYAKOBUSHI":      [0, 1, 5, 7, 8],
            "WHOLE_TONE":       [0, 2, 4, 6, 8, 10]
        };

        const SCALES = {};
        for (const [name, intervals] of Object.entries(SCALE_DEFINITIONS)) {
            SCALES[name] = generateScale(intervals);
        }
        
        let currentScaleName = "MINOR_PENTATONIC";

        async function initAudio() {
            if (isStarted) return;
            await Tone.start();
            
            // ★FFT Analyserの追加
            fft = new Tone.Analyser("fft", 64);
            fft.smoothing = 0.8;

            limiter = new Tone.Limiter(-1).connect(fft);
            fft.toDestination(); // FFTを通して出力

            chorus = new Tone.Chorus(4, 2.5, 0.5);
            reverb = new Tone.Reverb({ decay: 6, wet: 0.6 }); 
            eqLow = new Tone.Filter({ type: "lowshelf", frequency: localEQ.low.freq, gain: localEQ.low.gain, rolloff: -12 });
            eqMid = new Tone.Filter({ type: "peaking", frequency: localEQ.mid.freq, gain: localEQ.mid.gain, Q: 2.5 });
            eqHigh = new Tone.Filter({ type: "highshelf", frequency: localEQ.high.freq, gain: localEQ.high.gain, rolloff: -12 });
            
            reverb.connect(limiter); 
            chorus.connect(reverb);
            eqHigh.connect(chorus); 
            eqMid.connect(eqHigh); 
            eqLow.connect(eqMid);
            
            synth = new Tone.PolySynth(Tone.Synth, {
                maxPolyphony: 20, volume: localMixer.synth, oscillator: { type: "custom", partials: [1] }, envelope: localADSR
            }).connect(eqLow);
            
            const droneFilter = new Tone.Filter(800, "lowpass");
            droneSynth = new Tone.PolySynth(Tone.Synth, {
                maxPolyphony: 6, 
                volume: localMixer.drone, 
                oscillator: { type: "fatcustom", spread: 20, count: 3, partials: [1, 0.5, 0.3] }, 
                envelope: { attack: 2, decay: 0, sustain: 1, release: 5 }
            }).connect(droneFilter);
            droneFilter.connect(reverb);
            
            updateSynthWave(waveBuffer);

            startDroneLoop();
            isStarted = true;
            document.getElementById('overlay').style.display = 'none';
            updateLayout();
        }
        document.getElementById('overlay').addEventListener('click', initAudio);

        // --- Drone Logic (Fix: Restart loop on toggle) ---
        function startDroneLoop() {
            const triggerDrone = () => {
                if (!isDroneOn || !isStarted) { return; } // ここでループが途切れる
                const currentNotes = SCALES[currentScaleName];
                if (!currentNotes || currentNotes.length === 0) { setTimeout(triggerDrone, 1000); return; }

                const lowNotes = currentNotes.filter(n => n.includes('2') || n.includes('3'));
                if (lowNotes.length === 0) { setTimeout(triggerDrone, 1000); return; }

                const note = lowNotes[Math.floor(Math.random() * lowNotes.length)];
                droneSynth.triggerAttackRelease(note, 6, Tone.now());
                setTimeout(triggerDrone, 4000); 
            };
            triggerDrone();
        }

        const droneBtn = document.getElementById('drone-btn');
        droneBtn.addEventListener('click', (e) => {
            e.stopPropagation(); 
            isDroneOn = !isDroneOn;
            if (isDroneOn) { 
                droneBtn.textContent = "AMBIENT: ON"; 
                droneBtn.classList.add("active"); 
                // ★修正: ONにした時にループを再開させる
                if(isStarted) startDroneLoop();
            } else { 
                droneBtn.textContent = "AMBIENT: OFF"; 
                droneBtn.classList.remove("active"); 
                droneSynth.releaseAll(); 
            }
        });
        droneBtn.addEventListener('touchstart', (e) => e.stopPropagation(), {passive: false});

        // --- EQ & Spectrum ---
        const eqCanvas = document.getElementById('eq-canvas'); const eqCtx = eqCanvas.getContext('2d'); const eqReadout = document.getElementById('eq-readout');
        const minFreq = 20; const maxFreq = 20000;
        function xToFreq(x, width) { return minFreq * Math.pow(maxFreq / minFreq, x / width); }
        function freqToX(freq, width) { return (Math.log(freq / minFreq) / Math.log(maxFreq / minFreq)) * width; }
        function yToDb(y, height) { return 12 - (y / height) * 24; }
        function dbToY(db, height) { return height/2 - (db/24) * height; }
        function getEQResponse(f) {
            let db = 0;
            if (localEQ.low.gain !== 0) db += localEQ.low.gain * (1 / (1 + Math.pow(f / localEQ.low.freq, 4)));
            if (localEQ.high.gain !== 0) db += localEQ.high.gain * (1 / (1 + Math.pow(localEQ.high.freq / f, 4)));
            if (localEQ.mid.gain !== 0) { const Q=2.5; db += localEQ.mid.gain * Math.exp( -Math.pow( (Math.log(f/localEQ.mid.freq)) * Q, 2 ) ); }
            return db;
        }
        let draggingPoint = null;
        let lastEqSyncTime = 0;
        
        function drawEQ() {
            const w = eqCanvas.width; const h = eqCanvas.height; 
            eqCtx.clearRect(0, 0, w, h);

            // ★スペクトラム描画 (背景として)
            if (fft) {
                const values = fft.getValue(); // dB array
                const barWidth = w / values.length;
                eqCtx.fillStyle = 'rgba(0, 255, 204, 0.15)'; // 淡い光
                for (let i = 0; i < values.length; i++) {
                    const val = values[i]; // range usually -100 to 0
                    if (val === -Infinity) continue;
                    // Map dB to height: -100db -> 0px, 0db -> height
                    const barHeight = Math.max(0, (val + 100) / 100 * h);
                    eqCtx.fillRect(i * barWidth, h - barHeight, barWidth - 1, barHeight);
                }
            }

            // EQ Grid
            eqCtx.strokeStyle = 'rgba(255,255,255,0.1)'; eqCtx.lineWidth = 1; eqCtx.beginPath();
            [100, 1000, 10000].forEach(f => { const x = freqToX(f, w); eqCtx.moveTo(x, 0); eqCtx.lineTo(x, h); });
            eqCtx.moveTo(0, h/2); eqCtx.lineTo(w, h/2); eqCtx.stroke();
            
            // EQ Curve
            eqCtx.strokeStyle = '#00ffcc'; eqCtx.lineWidth = 2; eqCtx.beginPath();
            for (let x = 0; x < w; x+=2) { const y = dbToY(getEQResponse(xToFreq(x, w)), h); if (x === 0) eqCtx.moveTo(x, y); else eqCtx.lineTo(x, y); }
            eqCtx.stroke(); 
            
            // EQ Points
            [ {id:'low', c:'#ff0055'}, {id:'mid', c:'#ffff00'}, {id:'high', c:'#00ccff'} ].forEach(p => {
                const d = localEQ[p.id]; const x = freqToX(d.freq, w); const y = dbToY(d.gain, h);
                eqCtx.fillStyle = p.c; eqCtx.beginPath(); eqCtx.arc(x, y, 6, 0, Math.PI*2); eqCtx.fill();
                if(draggingPoint===p.id){ eqCtx.strokeStyle='#fff'; eqCtx.lineWidth=2; eqCtx.stroke(); }
            });
        }
        
        function handleEQMove(cx, cy, isDown) {
            const r = eqCanvas.getBoundingClientRect(); const x = Math.max(0, Math.min(r.width, cx - r.left)); const y = Math.max(0, Math.min(r.height, cy - r.top));
            if (isDown) {
                const pts = ['low','mid','high'].map(k => ({id:k, x:freqToX(localEQ[k].freq, r.width), y:dbToY(localEQ[k].gain, r.height)}));
                for(let p of pts) if(Math.hypot(p.x-x, p.y-y)<30) draggingPoint=p.id;
            }
            if (draggingPoint) {
                const f = xToFreq(x, r.width); const g = Math.max(-12, Math.min(12, yToDb(y, r.height)));
                localEQ[draggingPoint].freq=f; localEQ[draggingPoint].gain=g;
                if(eqLow){ 
                    if(draggingPoint==='low'){ eqLow.frequency.value=f; eqLow.gain.value=g; }
                    if(draggingPoint==='mid'){ eqMid.frequency.value=f; eqMid.gain.value=g; }
                    if(draggingPoint==='high'){ eqHigh.frequency.value=f; eqHigh.gain.value=g; }
                }
                eqReadout.textContent=`${draggingPoint.toUpperCase()}: ${Math.round(f)}Hz / ${g.toFixed(1)}dB`; 
                // drawEQ() is in animate loop now
                if (Date.now() - lastEqSyncTime > 30) { socket.emit('update_eq', localEQ); lastEqSyncTime = Date.now(); }
            }
        }
        function endEQDrag() { if(draggingPoint){ socket.emit('update_eq', localEQ); draggingPoint=null; eqReadout.textContent="DRAG POINTS"; }}
        eqCanvas.addEventListener('mousedown', e=>handleEQMove(e.clientX,e.clientY,true)); window.addEventListener('mousemove', e=>{if(draggingPoint)handleEQMove(e.clientX,e.clientY,false)}); window.addEventListener('mouseup', endEQDrag);
        eqCanvas.addEventListener('touchstart', e=>{e.preventDefault(); handleEQMove(e.touches[0].clientX,e.touches[0].clientY,true)},{passive:false}); window.addEventListener('touchmove', e=>{if(draggingPoint){e.preventDefault(); handleEQMove(e.touches[0].clientX,e.touches[0].clientY,false)}},{passive:false}); window.addEventListener('touchend', endEQDrag);
        
        // --- Mixer & ADSR & Waveform ---
        const volSynth=document.getElementById('vol-synth'), volDrone=document.getElementById('vol-drone');
        let lastMixerSync = 0;
        const updateMixer=(v)=>{localMixer=v; volSynth.value=v.synth; volDrone.value=v.drone; if(synth)synth.volume.value=v.synth; if(droneSynth)droneSynth.volume.value=v.drone;};
        [volSynth, volDrone].forEach(e=>{
            e.addEventListener('input',()=>{ updateMixer({synth:parseFloat(volSynth.value),drone:parseFloat(volDrone.value)}); if(Date.now()-lastMixerSync>30){socket.emit('update_mixer',localMixer);lastMixerSync=Date.now();} }); 
            e.addEventListener('change',()=>socket.emit('update_mixer',localMixer)); 
            e.addEventListener('touchstart',ev=>ev.stopPropagation(),{passive:false}); e.addEventListener('mousedown',ev=>ev.stopPropagation())
        });

        const waveCanvas=document.getElementById('wave-canvas'), waveCtx=waveCanvas.getContext('2d'), resetBtn=document.getElementById('reset-btn');
        const WAVE_SIZE=128; let waveBuffer=new Array(WAVE_SIZE).fill(0).map((_,i)=>Math.sin((i/WAVE_SIZE)*Math.PI*2));
        let lastWaveSync = 0;
        function drawWave(b){ 
            const w=waveCanvas.width, h=waveCanvas.height, c=h/2;
            waveCtx.clearRect(0,0,w,h); waveCtx.strokeStyle='#333'; waveCtx.beginPath(); waveCtx.moveTo(0,c); waveCtx.lineTo(w,c); waveCtx.stroke(); 
            waveCtx.beginPath(); waveCtx.strokeStyle='#00ffcc'; waveCtx.lineWidth=2; 
            for(let i=0;i<WAVE_SIZE;i++){ const x=(i/(WAVE_SIZE-1))*w, y=c-(b[i]*(h/2)); if(i===0)waveCtx.moveTo(x,y); else waveCtx.lineTo(x,y); } 
            waveCtx.stroke(); waveCtx.lineTo(w,c); waveCtx.lineTo(0,c); waveCtx.fillStyle='rgba(0, 255, 204, 0.1)'; waveCtx.fill(); 
        }
        
        let isDrawingWave=false;
        function updateWave(cx,cy){ 
            const r=waveCanvas.getBoundingClientRect(); const nx=Math.max(0,Math.min(1,(cx-r.left)/r.width)), ny=-((Math.max(0,Math.min(1,(cy-r.top)/r.height))*2)-1);
            const idx=Math.floor(nx*(WAVE_SIZE-1)); if(idx>=0&&idx<WAVE_SIZE) waveBuffer[idx]=ny; 
            drawWave(waveBuffer); 
            updateSynthWave(waveBuffer);
            if(Date.now() - lastWaveSync > 30) { socket.emit('update_waveform', waveBuffer); lastWaveSync = Date.now(); }
        }
        
        const handleWaveStart = e => { 
            isDrawingWave = true; 
            if(e.type === 'mousedown') handleWaveMove(e);
            else if(e.type === 'touchstart') { e.preventDefault(); const t = e.touches[0]; updateWave(t.clientX, t.clientY); }
        }; 
        const handleWaveEnd = () => { if(isDrawingWave){isDrawingWave=false; socket.emit('update_waveform',waveBuffer)} }; 
        const handleWaveMove = e => { 
            if(!isDrawingWave) return; 
            e.preventDefault(); 
            const t = e.touches ? e.touches[0] : e; updateWave(t.clientX, t.clientY); 
        };
        
        waveCanvas.addEventListener('mousedown', handleWaveStart); window.addEventListener('mouseup', handleWaveEnd); waveCanvas.addEventListener('mousemove', handleWaveMove);
        waveCanvas.addEventListener('touchstart', handleWaveStart, {passive: false}); window.addEventListener('touchend', handleWaveEnd); waveCanvas.addEventListener('touchmove', handleWaveMove, {passive: false});
        
        resetBtn.addEventListener('click', e=>{e.stopPropagation(); waveBuffer=waveBuffer.map((_,i)=>Math.sin((i/WAVE_SIZE)*Math.PI*2)); drawWave(waveBuffer); updateSynthWave(waveBuffer); socket.emit('update_waveform',waveBuffer)});
        resetBtn.addEventListener('touchstart', e=>e.stopPropagation(),{passive:false});

        function updateSynthWave(buffer) {
            if(!synth) return;
            const N = buffer.length; const numHarmonics = 32; const partials = [];
            for (let k = 1; k <= numHarmonics; k++) {
                let r = 0, i = 0;
                for (let n = 0; n < N; n++) {
                    const angle = (2 * Math.PI * k * n) / N;
                    r += buffer[n] * Math.cos(angle);
                    i += buffer[n] * Math.sin(angle);
                }
                partials.push(Math.sqrt(r * r + i * i));
            }
            const max = Math.max(...partials);
            synth.set({oscillator:{partials:max>0.0001?partials.map(v=>v/max):partials}});
        }

        const adsrC=document.getElementById('adsr-canvas'), adsrCtx=adsrC.getContext('2d'), slA=document.getElementById('adsr-a'), slD=document.getElementById('adsr-d'), slS=document.getElementById('adsr-s'), slR=document.getElementById('adsr-r');
        let lastAdsrSync = 0;
        function drawADSRVisual(){ 
            const w=adsrC.width, h=adsrC.height;
            adsrCtx.clearRect(0,0,w,h); adsrCtx.fillStyle='rgba(0,0,0,0.3)'; adsrCtx.fillRect(0,0,w,h);
            const A=parseFloat(slA.value), D=parseFloat(slD.value), S=parseFloat(slS.value), R=parseFloat(slR.value);
            adsrCtx.beginPath(); adsrCtx.strokeStyle='#00ffcc'; adsrCtx.lineWidth=2;
            const x1=(A/2)*(w*0.25), y2=h-(S*h), x2=x1+(D/2)*(w*0.25), x3=x2+(w*0.2), x4=Math.min(w,x3+(R/5)*(w*0.3));
            adsrCtx.moveTo(0,h); adsrCtx.lineTo(x1,0); adsrCtx.lineTo(x2,y2); adsrCtx.lineTo(x3,y2); adsrCtx.lineTo(x4,h); adsrCtx.stroke();
        }
        const updateADSR=()=>{ 
            localADSR={attack:parseFloat(slA.value),decay:parseFloat(slD.value),sustain:parseFloat(slS.value),release:parseFloat(slR.value)}; 
            drawADSRVisual(); if(synth)synth.set({envelope:localADSR}); 
            if(Date.now() - lastAdsrSync > 30) { socket.emit('update_adsr',localADSR); lastAdsrSync = Date.now(); }
        };
        [slA,slD,slS,slR].forEach(s=>{ s.addEventListener('input',updateADSR); s.addEventListener('change',()=>socket.emit('update_adsr',localADSR)); s.addEventListener('touchstart',e=>e.stopPropagation(),{passive:false}); s.addEventListener('mousedown',e=>e.stopPropagation()) });

        const scaleBtns = document.querySelectorAll('.scale-btn');
        scaleBtns.forEach(btn => {
            btn.addEventListener('click', (e) => { e.stopPropagation(); socket.emit('update_scale', btn.dataset.scale); });
            btn.addEventListener('touchstart', e=>e.stopPropagation(), {passive:false});
        });

        // --- Swipe to Play ---
        let isPointerDown = false;
        let lastMoveNoteTime = 0;
        const MOVE_NOTE_INTERVAL = 100;

        function triggerNoteFromInput(normX, normY) {
            if (normX < 0 || normX > 1 || normY < 0 || normY > 1) return;
            const scaleNotes = SCALES[currentScaleName];
            const noteIndex = Math.floor((1 - normY) * scaleNotes.length);
            const note = scaleNotes[Math.min(noteIndex, scaleNotes.length - 1)];
            socket.emit('play_note', { note, duration: 0.5 + normX * 4.0, normX, normY });
        }

        function handleInput(e, isMove) {
            if (!isStarted) return;
            const target = e.target;
            if (['INPUT', 'BUTTON'].includes(target.tagName)) return;
            if (['wave-canvas','adsr-canvas','eq-canvas'].includes(target.id)) return;

            const cX = e.touches ? e.touches[0].clientX : e.clientX;
            const cY = e.touches ? e.touches[0].clientY : e.clientY;
            
            const controlsRect = document.getElementById('controls').getBoundingClientRect();
            if (controlsRect.top <= cY) return;

            const w = window.innerWidth; const h = window.innerHeight;
            const centerX = w / 2; const centerY = (h / 2) - playAreaOffsetY;
            const normX = ((cX - centerX) / playAreaSize) + 0.5;
            const normY = ((cY - centerY) / playAreaSize) + 0.5;

            if (isMove) {
                const now = Date.now();
                if (now - lastMoveNoteTime > MOVE_NOTE_INTERVAL) {
                    triggerNoteFromInput(normX, normY);
                    lastMoveNoteTime = now;
                }
            } else {
                triggerNoteFromInput(normX, normY);
                lastMoveNoteTime = Date.now();
            }
        }

        function onPointerDown(e) { isPointerDown = true; handleInput(e, false); }
        function onPointerMove(e) { 
            if (isPointerDown) {
                const target = e.target;
                const inControls = document.getElementById('controls').contains(target);
                if (!inControls) { e.preventDefault(); handleInput(e, true); }
            }
        }
        function onPointerUp() { isPointerDown = false; prevNotePos = null; }

        window.addEventListener('mousedown', onPointerDown); window.addEventListener('mousemove', onPointerMove); window.addEventListener('mouseup', onPointerUp);
        window.addEventListener('touchstart', onPointerDown, {passive: false}); window.addEventListener('touchmove', onPointerMove, {passive: false}); window.addEventListener('touchend', onPointerUp);

        socket.on('trigger_note', (data) => {
            if (!synth) return;
            synth.triggerAttackRelease(data.note, data.duration);
            const xPos = (data.normX - 0.5) * playAreaSize;
            const yPos = -(data.normY - 0.5) * playAreaSize + playAreaOffsetY;
            const pos = new THREE.Vector3(xPos, yPos, 0);

            const mesh = new THREE.Mesh(new THREE.RingGeometry(0.99, 1.0, 64), new THREE.MeshBasicMaterial({ 
                color: data.id === socket.id ? 0x00ffcc : 0xff00cc, 
                transparent: true, 
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending 
            }));
            mesh.position.copy(pos);
            scene.add(mesh);
            visualObjects.push({ type: 'ring', mesh, startTime: Date.now(), duration: data.duration });

            if (prevNotePos) {
                const points = [prevNotePos.clone(), pos.clone()];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: 0x00ffcc, transparent: true, opacity: 0.2, blending: THREE.AdditiveBlending });
                const line = new THREE.Line(geometry, material);
                scene.add(line);
                visualObjects.push({ type: 'line', mesh: line, startTime: Date.now(), duration: data.duration * 2.0 }); 
            }
            prevNotePos = pos;
        });

        socket.on('sync_waveform', d => { waveBuffer=d; resizeCanvases(); updateSynthWave(d); });
        socket.on('sync_adsr', d => { localADSR=d; slA.value=d.attack; slD.value=d.decay; slS.value=d.sustain; slR.value=d.release; resizeCanvases(); if(synth)synth.set({envelope:d}); });
        socket.on('sync_mixer', d => updateMixer(d));
        socket.on('sync_eq', d => { localEQ=d; resizeCanvases(); if(eqLow){ eqLow.frequency.value=d.low.freq; eqLow.gain.value=d.low.gain; eqMid.frequency.value=d.mid.freq; eqMid.gain.value=d.mid.gain; eqHigh.frequency.value=d.high.freq; eqHigh.gain.value=d.high.gain; } });
        socket.on('sync_scale', (scaleName) => { currentScaleName = scaleName; scaleBtns.forEach(btn => { if(btn.dataset.scale === scaleName) btn.classList.add('active'); else btn.classList.remove('active'); }); });
    </script>
</body>
</html>
