<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Synth Master Sync</title>
    <style>
        body { margin: 0; overflow: hidden; background: #080808; touch-action: none; color: white; font-family: monospace; }
        
        #controls {
            position: fixed; bottom: 0; left: 0; width: 100%; height: 280px; 
            background: linear-gradient(transparent, rgba(0,0,0,0.95) 15%);
            display: flex; flex-direction: row; justify-content: center; align-items: center;
            padding-bottom: 20px; z-index: 50; gap: 15px; box-sizing: border-box;
            touch-action: pan-x; -webkit-overflow-scrolling: touch;
        }
        #controls * { touch-action: pan-x; }

        .panel-section {
            display: flex; flex-direction: column; align-items: center;
            background: rgba(10, 10, 10, 0.85); border: 1px solid #333; border-radius: 6px;
            padding: 10px;
            backdrop-filter: blur(10px); width: 260px; height: 210px;
            justify-content: flex-start; box-shadow: 0 4px 15px rgba(0,0,0,0.6);
            flex-shrink: 0; position: relative; transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s;
        }
        .panel-section:hover { border-color: #555; box-shadow: 0 0 20px rgba(0, 255, 204, 0.1); }
        
        .label { font-size: 11px; color: #00ffcc; margin-bottom: 8px; letter-spacing: 2px; text-shadow: 0 0 8px rgba(0,255,204,0.6); font-weight: bold; text-transform: uppercase; pointer-events: none; }

        #wave-canvas, #eq-canvas, #adsr-canvas { background: rgba(0, 0, 0, 0.5); border: 1px solid #444; border-radius: 4px; box-shadow: inset 0 0 15px rgba(0,0,0,0.8); width: 240px; }
        
        #wave-canvas { height: 90px; cursor: crosshair; }
        #eq-canvas { height: 100px; }
        #adsr-canvas { height: 70px; }

        .eq-values { font-size: 10px; color: #888; width: 100%; text-align: center; margin-top: 5px; font-family: monospace; pointer-events: none; }
        .mixer-container { display: flex; gap: 30px; height: 100%; align-items: center; justify-content: center; }
        #adsr-container { display: flex; flex-direction: column; align-items: center; width: 100%; }
        .sliders { display: flex; gap: 10px; width: 100%; justify-content: space-between; margin-top: 5px; }
        .slider-group { display: flex; flex-direction: column; align-items: center; position: relative; }
        
        input[type=range].vertical {
            -webkit-appearance: none; appearance: none; width: 30px; height: 100px;
            background: transparent; outline: none; writing-mode: bt-lr; -webkit-appearance: slider-vertical;
            cursor: pointer; position: relative; z-index: 2;
            background: linear-gradient(to right, transparent 13px, #222 13px, #222 17px, transparent 17px);
            touch-action: pan-x; 
        }
        input[type=range].vertical::-webkit-slider-thumb {
            -webkit-appearance: none; width: 28px; height: 14px; background: #000; 
            border: 1px solid #00ffcc; border-radius: 2px; box-shadow: 0 0 8px rgba(0,255,204,0.4);
            margin-top: 0; position: relative; z-index: 3;
        }
        .param-label { font-size: 10px; color: #666; margin-top: 6px; font-weight: bold; letter-spacing: 1px; pointer-events: none; }

        .btn-group { display: flex; gap: 10px; margin-top: 10px; }
        button {
            background: rgba(0,0,0,0.6); border: 1px solid #333; border-bottom: 2px solid #333;
            color: #00ffcc; font-size: 10px; padding: 6px 14px; cursor: pointer; border-radius: 2px;
            transition: all 0.1s; font-family: monospace; touch-action: pan-x;
        }
        button:hover { background: rgba(0, 255, 204, 0.1); border-color: #00ffcc; }
        button.active { background: #00ffcc; color: #000; border-color: #00ffcc; box-shadow: 0 0 15px rgba(0,255,204,0.6); font-weight: bold; }

        .scale-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; width: 100%; margin-top: 5px; height: 100%; overflow-y: auto; align-content: start; }
        .scale-btn { padding: 8px 4px; font-size: 9px; text-align: left; width: 100%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; touch-action: pan-x; border: 1px solid #333; background: rgba(0,0,0,0.3); box-sizing: border-box; }
        .scale-btn.active { border-color: #00ffcc; background: rgba(0,255,204,0.2); color: white; box-shadow: 0 0 8px rgba(0,255,204,0.3); }

        #status-bar {
            position: fixed; top: 20px; left: 20px; z-index: 100;
            display: flex; gap: 10px; align-items: center;
            font-size: 10px; color: #888;
        }
        #user-count { font-weight: bold; }
        .my-color-dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-left: 5px; border: 1px solid #fff; }

        #sensor-btn {
            position: fixed; top: 20px; right: 20px; z-index: 100;
            background: rgba(0,0,0,0.5); border: 1px solid #444; color: #888;
            padding: 8px 12px; font-size: 10px; border-radius: 20px;
            cursor: pointer;
        }
        #sensor-btn.active { border-color: #00ffcc; color: #00ffcc; background: rgba(0,255,204,0.1); }

        #sensor-panel {
            position: fixed; top: 60px; right: 20px; z-index: 90;
            display: flex; gap: 12px;
        }
        .sensor-group { display: flex; flex-direction: column; align-items: center; gap: 5px; }
        .sensor-meter {
            width: 10px; height: 80px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            position: relative; overflow: hidden;
            display: flex; flex-direction: column-reverse;
            border: 1px solid #333;
        }
        .sensor-fill {
            width: 100%; height: 50%;
            background: #00ffcc; transition: height 0.1s;
            box-shadow: 0 0 10px #00ffcc;
        }
        .target-btn {
            font-size: 9px; color: #00ffcc; background: rgba(0,0,0,0.6);
            border: 1px solid #444; padding: 4px; width: 45px;
            text-align: center; cursor: pointer; border-radius: 4px;
            white-space: nowrap;
        }

        @media (min-width: 1100px) { #controls { justify-content: center; gap: 20px; } }
        @media (max-width: 1099px) { 
            #controls { justify-content: flex-start; overflow-x: auto; padding: 10px 20px 30px 20px; scroll-snap-type: x mandatory; } 
            #controls::-webkit-scrollbar { display: none; } 
            .panel-section { scroll-snap-align: center; margin-right: 5px; } 
        }
    </style>
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    
    <div id="status-bar">
        <span id="user-count">ONLINE: 1</span>
        <span>YOU: <span id="my-color" class="my-color-dot"></span></span>
    </div>

    <button id="sensor-btn">SENSOR: OFF</button>
    
    <div id="sensor-panel">
        <div class="sensor-group">
            <div class="sensor-meter"><div class="sensor-fill" id="fill-x"></div></div>
            <button class="target-btn" id="target-x-btn">FILTER</button>
        </div>
        <div class="sensor-group">
            <div class="sensor-meter"><div class="sensor-fill" id="fill-y" style="background:#ff00cc; box-shadow: 0 0 10px #ff00cc;"></div></div>
            <button class="target-btn" id="target-y-btn">REVERB</button>
        </div>
    </div>

    <div id="controls">
        <div class="panel-section" id="panel-wave">
            <div class="label">1. WAVEFORM</div>
            <canvas id="wave-canvas" width="240" height="90"></canvas>
            <div class="btn-group">
                <button id="reset-btn">RESET</button>
                <button id="auto-btn">AUTO: OFF</button>
            </div>
        </div>

        <div class="panel-section" id="panel-eq">
            <div class="label">2. EQ & SPECTRUM</div>
            <div id="eq-container" style="width:100%; height:100%; display:flex; flex-direction:column; align-items:center; justify-content:center;">
                <canvas id="eq-canvas" width="240" height="100"></canvas>
                <div class="eq-values" id="eq-readout">DRAG POINTS</div>
            </div>
        </div>

        <div class="panel-section" id="panel-mixer">
            <div class="label">3. MIXER & AUTO</div>
            <div class="mixer-container">
                <div class="slider-group"><input type="range" class="vertical" id="vol-synth" min="-60" max="0" step="1" value="-6"><span class="param-label">VOL</span></div>
                <div class="slider-group"><input type="range" class="vertical" id="auto-speed" min="0" max="100" step="1" value="30"><span class="param-label">FREQ</span></div>
            </div>
        </div>

        <div class="panel-section" id="panel-adsr">
            <div class="label">4. ENVELOPE</div>
            <div id="adsr-container">
                <canvas id="adsr-canvas" width="240" height="70"></canvas>
                <div class="sliders">
                    <div class="slider-group"><input type="range" class="vertical" id="adsr-a" min="0.01" max="2.0" step="0.01" value="0.1"><span class="param-label">A</span></div>
                    <div class="slider-group"><input type="range" class="vertical" id="adsr-d" min="0.1" max="2.0" step="0.01" value="0.1"><span class="param-label">D</span></div>
                    <div class="slider-group"><input type="range" class="vertical" id="adsr-s" min="0" max="1.0" step="0.01" value="0.5"><span class="param-label">S</span></div>
                    <div class="slider-group"><input type="range" class="vertical" id="adsr-r" min="0.1" max="5.0" step="0.1" value="0.3"><span class="param-label">R</span></div>
                </div>
            </div>
        </div>

        <div class="panel-section" id="panel-scale">
            <div class="label">5. SCALE (MOOD)</div>
            <div class="scale-grid">
                <button class="scale-btn active" data-scale="MINOR_PENTATONIC">MINOR PENTATONIC</button>
                <button class="scale-btn" data-scale="MAJOR">MAJOR (BRIGHT)</button>
                <button class="scale-btn" data-scale="MINOR">MINOR (DARK)</button>
                <button class="scale-btn" data-scale="DORIAN">DORIAN (COOL)</button>
                <button class="scale-btn" data-scale="LYDIAN">LYDIAN (ETHEREAL)</button>
                <button class="scale-btn" data-scale="RYUKYU">RYUKYU (ISLAND)</button>
                <button class="scale-btn" data-scale="MIYAKOBUSHI">MIYAKOBUSHI</button>
                <button class="scale-btn" data-scale="WHOLE_TONE">WHOLE TONE</button>
            </div>
        </div>
    </div>

    <script>
        const socket = io();
        let isStarted = false;
        let myId = null;
        let myColor = '#00ffcc';
        let connectedUsers = {};
        
        // ★パラメータのローカルコピー
        let localParams = {
            'FILTER': 0.5, 'PAN': 0.5, 'VOL': 0.8, 'REVERB': 0.0,
            'ATTACK': 0.05, 'DECAY': 0.1, 'SUSTAIN': 0.5, 'RELEASE': 0.3
        };
        // ADSRの実値 (描画用)
        let localADSR = { attack: 0.05, decay: 0.1, sustain: 0.5, release: 0.3 };
        
        let synth, limiter, chorus, reverb, fft, panner; 
        let eqLow, eqMid, eqHigh, globalFilter; 

        let playAreaSize = 0;
        let playAreaMesh;
        let playAreaOffsetY = 0; 
        let prevNotePos = null;

        // --- Visuals ---
        const scene = new THREE.Scene();
        const width = window.innerWidth;
        const height = window.innerHeight;
        const camera = new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, 1, 1000);
        camera.position.z = 10;
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(width, height);
        renderer.domElement.id = 'main-canvas';
        document.body.appendChild(renderer.domElement);

        function updateLayout() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            const controlsEl = document.getElementById('controls');
            const controlsHeight = controlsEl ? controlsEl.offsetHeight : 0;
            const availableHeight = h - controlsHeight;
            playAreaSize = Math.min(w, availableHeight) * 0.9;
            playAreaOffsetY = controlsHeight / 2;
            camera.left = w / -2; camera.right = w / 2;
            camera.top = h / 2; camera.bottom = h / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(w, h);
            if (playAreaMesh) scene.remove(playAreaMesh);
            const borderGeo = new THREE.EdgesGeometry(new THREE.PlaneGeometry(playAreaSize, playAreaSize));
            const borderMat = new THREE.LineBasicMaterial({ color: 0x444444 });
            playAreaMesh = new THREE.LineSegments(borderGeo, borderMat);
            playAreaMesh.position.y = playAreaOffsetY;
            scene.add(playAreaMesh);
            resizeCanvases();
        }
        function resizeCanvases() {
            const wCanvas = document.getElementById('wave-canvas');
            const eCanvas = document.getElementById('eq-canvas');
            const aCanvas = document.getElementById('adsr-canvas');
            wCanvas.width = 240; wCanvas.height = 90;
            eCanvas.width = 240; eCanvas.height = 100;
            aCanvas.width = 240; aCanvas.height = 70;
            drawWave(waveBuffer); 
            drawADSRVisual();
        }
        window.addEventListener('resize', updateLayout);
        setTimeout(updateLayout, 100);

        const visualObjects = []; 
        function animate() {
            requestAnimationFrame(animate);
            if(isStarted) drawEQ();

            const now = Date.now();
            for (let i = visualObjects.length - 1; i >= 0; i--) {
                const obj = visualObjects[i];
                const progress = (now - obj.startTime) / (obj.duration * 1000);
                if (progress >= 1) {
                    scene.remove(obj.mesh);
                    visualObjects.splice(i, 1);
                } else {
                    if(obj.type === 'ring') {
                        const scale = (playAreaSize * 0.02) + (progress * playAreaSize * 0.4);
                        obj.mesh.scale.set(scale, scale, 1);
                        obj.mesh.material.opacity = (1 - Math.pow(progress, 2)) * 0.3;
                    } else if (obj.type === 'line') {
                        obj.mesh.material.opacity = (1 - progress) * 0.2;
                    }
                }
            }
            renderer.render(scene, camera);
        }
        animate();

        let localMixer = { synth: -4 };
        let localEQ = { low: {freq:100, gain:4}, mid: {freq:1000, gain:-2}, high: {freq:5000, gain:-6} };
        let localAuto = { active: false, speed: 30 };

        const NOTE_NAMES = ["C", "Db", "D", "Eb", "E", "F", "F#", "G", "Ab", "A", "Bb", "B"];
        function generateScale(intervals) {
            const notes = [];
            for (let oct = 2; oct <= 7; oct++) {
                for (let i = 0; i < 12; i++) {
                    if (intervals.includes(i)) {
                        if (oct === 7 && i > 0) break;
                        notes.push(NOTE_NAMES[i] + oct);
                    }
                }
            }
            return notes;
        }

        const SCALE_DEFINITIONS = {
            "MINOR_PENTATONIC": [0, 3, 5, 7, 10], 
            "MAJOR":            [0, 2, 4, 5, 7, 9, 11],
            "MINOR":            [0, 2, 3, 5, 7, 8, 10],
            "DORIAN":           [0, 2, 3, 5, 7, 9, 10],
            "LYDIAN":           [0, 2, 4, 6, 7, 9, 11],
            "RYUKYU":           [0, 4, 5, 7, 11],
            "MIYAKOBUSHI":      [0, 1, 5, 7, 8],
            "WHOLE_TONE":       [0, 2, 4, 6, 8, 10]
        };

        const SCALES = {};
        for (const [name, intervals] of Object.entries(SCALE_DEFINITIONS)) {
            SCALES[name] = generateScale(intervals);
        }
        
        let currentScaleName = "MINOR_PENTATONIC";

        async function initAudio() {
            if (isStarted) return;
            await Tone.start();
            isStarted = true;
            
            fft = new Tone.Analyser("fft", 256);
            fft.smoothing = 0.85;

            limiter = new Tone.Limiter(-1).connect(fft);
            fft.toDestination(); 

            chorus = new Tone.Chorus(4, 2.5, 0.5);
            reverb = new Tone.Reverb({ decay: 5, wet: 0.5 }); 
            globalFilter = new Tone.Filter(4000, "lowpass", -12);
            panner = new Tone.Panner(0);

            eqLow = new Tone.Filter({ type: "lowshelf", frequency: localEQ.low.freq, gain: localEQ.low.gain, rolloff: -12 });
            eqMid = new Tone.Filter({ type: "peaking", frequency: localEQ.mid.freq, gain: localEQ.mid.gain, Q: 2.5 });
            eqHigh = new Tone.Filter({ type: "highshelf", frequency: localEQ.high.freq, gain: localEQ.high.gain, rolloff: -12 });
            
            reverb.connect(limiter); 
            chorus.connect(reverb);
            globalFilter.connect(chorus);
            eqHigh.connect(globalFilter); 
            eqMid.connect(eqHigh); 
            eqLow.connect(eqMid);
            panner.connect(eqLow);

            synth = new Tone.PolySynth(Tone.Synth, {
                maxPolyphony: 20, 
                volume: localMixer.synth, 
                oscillator: { type: "triangle" },
                envelope: localADSR
            }).connect(panner); 

            updateSynthWave(waveBuffer);
            updateLayout();
        }
        
        ['click', 'touchstart', 'keydown'].forEach(evt => {
            window.addEventListener(evt, () => {
                if(!isStarted) initAudio();
            }, { once: true });
        });

        // --- Visual Feedback ---
        function flashPanel(panelId, color) {
            const panel = document.getElementById(panelId);
            if(panel) {
                panel.style.borderColor = color;
                panel.style.boxShadow = `0 0 30px ${color}`;
                setTimeout(() => {
                    panel.style.borderColor = "#333";
                    panel.style.boxShadow = "none";
                }, 200);
            }
        }

        // --- Sensor Logic & Param Update ---
        const sensorBtn = document.getElementById('sensor-btn');
        const fillX = document.getElementById('fill-x');
        const fillY = document.getElementById('fill-y');
        const targetXBtn = document.getElementById('target-x-btn');
        const targetYBtn = document.getElementById('target-y-btn');

        let isSensorActive = false;
        let lastSensorSync = 0;
        
        const TARGETS_X = ['FILTER', 'PAN', 'VOL'];
        const TARGETS_Y = ['REVERB', 'ATTACK', 'DECAY', 'SUSTAIN', 'RELEASE'];
        let myTargets = { x: 'FILTER', y: 'REVERB' };

        // ★重要: パラメータ適用とUI/変数の同期
        function applyAudioParam(target, val) {
            localParams[target] = val; // 値を保存
            if (!synth) return;

            if (target === 'FILTER') {
                const freq = 100 * Math.pow(80, val); 
                if(globalFilter) globalFilter.frequency.rampTo(freq, 0.1);
            } 
            else if (target === 'PAN') {
                const panVal = (val * 2) - 1;
                if(panner) panner.pan.rampTo(panVal, 0.1);
            } 
            else if (target === 'VOL') {
                const vol = (val * 60) - 60;
                synth.volume.rampTo(vol, 0.1);
                const volSlider = document.getElementById('vol-synth');
                if(volSlider) volSlider.value = vol;
            } 
            else if (target === 'REVERB') {
                if(reverb) reverb.wet.rampTo(val, 0.1);
            } 
            // ADSR系は localADSR も更新する
            else if (target === 'ATTACK') {
                const a = 0.01 + (val * 1.99);
                synth.set({ envelope: { attack: a } });
                localADSR.attack = a; // Update local data
                const aSlider = document.getElementById('adsr-a');
                if(aSlider) { aSlider.value = a; drawADSRVisual(); }
            }
            else if (target === 'DECAY') {
                const d = 0.1 + (val * 1.9);
                synth.set({ envelope: { decay: d } });
                localADSR.decay = d;
                const dSlider = document.getElementById('adsr-d');
                if(dSlider) { dSlider.value = d; drawADSRVisual(); }
            } 
            else if (target === 'SUSTAIN') {
                const s = val;
                synth.set({ envelope: { sustain: s } });
                localADSR.sustain = s;
                const sSlider = document.getElementById('adsr-s');
                if(sSlider) { sSlider.value = s; drawADSRVisual(); }
            }
            else if (target === 'RELEASE') {
                const r = 0.1 + (val * 4.9);
                synth.set({ envelope: { release: r } });
                localADSR.release = r;
                const rSlider = document.getElementById('adsr-r');
                if(rSlider) { rSlider.value = r; drawADSRVisual(); }
            }
        }

        function updateSensorVisuals(target, val) {
            if (myTargets.x === target) fillX.style.height = (val * 100) + "%";
            if (myTargets.y === target) fillY.style.height = (val * 100) + "%";
        }

        function triggerVisualFeedback(target, color) {
            if (target === 'FILTER' || target === 'REVERB') flashPanel('panel-eq', color);
            if (target === 'PAN' || target === 'VOL') flashPanel('panel-mixer', color);
            if (['ATTACK','DECAY','SUSTAIN','RELEASE'].includes(target)) flashPanel('panel-adsr', color);
        }

        function handleSensor(e) {
            if (!isStarted || !isSensorActive) return;
            
            const gamma = e.gamma || 0; 
            const normGamma = Math.max(-1, Math.min(1, gamma / 45)); 
            const valX = (normGamma + 1) / 2; 

            const beta = e.beta || 0; 
            const normBeta = Math.max(-1, Math.min(1, (beta - 45) / 45));
            const valY = (1.0 - ((normBeta + 1) / 2)); 

            applyAudioParam(myTargets.x, valX);
            applyAudioParam(myTargets.y, valY);
            updateSensorVisuals(myTargets.x, valX);
            updateSensorVisuals(myTargets.y, valY);

            const now = Date.now();
            if (now - lastSensorSync > 100) {
                socket.emit('update_param', { target: myTargets.x, value: valX });
                socket.emit('update_param', { target: myTargets.y, value: valY });
                lastSensorSync = now;
            }
        }

        targetXBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const idx = TARGETS_X.indexOf(myTargets.x);
            myTargets.x = TARGETS_X[(idx + 1) % TARGETS_X.length];
            targetXBtn.textContent = myTargets.x;
        });
        targetXBtn.addEventListener('touchstart', e=>e.stopPropagation(),{passive:false});

        targetYBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const idx = TARGETS_Y.indexOf(myTargets.y);
            myTargets.y = TARGETS_Y[(idx + 1) % TARGETS_Y.length];
            targetYBtn.textContent = myTargets.y;
        });
        targetYBtn.addEventListener('touchstart', e=>e.stopPropagation(),{passive:false});

        sensorBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const permission = await DeviceOrientationEvent.requestPermission();
                    if (permission === 'granted') toggleSensor();
                    else alert("Permission denied");
                } catch (err) { console.error(err); }
            } else {
                toggleSensor();
            }
        });
        
        function toggleSensor() {
            isSensorActive = !isSensorActive;
            if (isSensorActive) {
                sensorBtn.textContent = "SENSOR: ON";
                sensorBtn.classList.add("active");
                window.addEventListener('deviceorientation', handleSensor);
            } else {
                sensorBtn.textContent = "SENSOR: OFF";
                sensorBtn.classList.remove("active");
                window.removeEventListener('deviceorientation', handleSensor);
            }
        }

        // --- Socket Events ---
        
        socket.on('init_setup', (data) => {
            myId = data.id;
            myColor = data.color;
            document.getElementById('my-color').style.backgroundColor = myColor;
            
            if(data.params) {
                for (const [key, val] of Object.entries(data.params)) {
                    applyAudioParam(key, val);
                }
            }
            if(data.waveform) waveBuffer = data.waveform;
            if(data.mixer) updateMixer(data.mixer);
            if(data.eq) { localEQ = data.eq; }
            if(data.scale) { currentScaleName = data.scale; scaleBtns.forEach(btn => { if(btn.dataset.scale === currentScaleName) btn.classList.add('active'); else btn.classList.remove('active'); }); }
            if(data.auto) { localAuto = data.auto; updateAutoUI(); }
            
            resizeCanvases();
        });

        socket.on('update_users', (users) => {
            connectedUsers = users;
            const count = Object.keys(users).length;
            document.getElementById('user-count').textContent = `ONLINE: ${count}`;
        });

        socket.on('sync_param', (data) => {
            applyAudioParam(data.target, data.value);
            const user = connectedUsers[data.userId];
            const color = user ? user.color : '#fff';
            triggerVisualFeedback(data.target, color);
        });

        socket.on('sync_waveform', d => { 
            waveBuffer=d.data; resizeCanvases(); updateSynthWave(d.data); 
            flashPanel('panel-wave', connectedUsers[d.userId]?.color || '#fff');
        });
        // Sync EQ
        socket.on('sync_eq', d => { 
            localEQ=d.data; resizeCanvases(); 
            if(eqLow){ eqLow.frequency.value=d.data.low.freq; eqLow.gain.value=d.data.low.gain; eqMid.frequency.value=d.data.mid.freq; eqMid.gain.value=d.data.mid.gain; eqHigh.frequency.value=d.data.high.freq; eqHigh.gain.value=d.data.high.gain; }
            flashPanel('panel-eq', connectedUsers[d.userId]?.color || '#fff');
        });
        socket.on('sync_scale', (d) => { 
            currentScaleName = d.scale; 
            scaleBtns.forEach(btn => { if(btn.dataset.scale === currentScaleName) btn.classList.add('active'); else btn.classList.remove('active'); }); 
            flashPanel('panel-scale', connectedUsers[d.userId]?.color || '#fff');
        });
        socket.on('sync_auto', (d) => {
            localAuto = d.data; updateAutoUI();
            flashPanel('panel-mixer', connectedUsers[d.userId]?.color || '#fff');
        });

        socket.on('trigger_note', (data) => {
            if (!synth) return;
            synth.triggerAttackRelease(data.note, data.duration);
            const xPos = (data.normX - 0.5) * playAreaSize;
            const yPos = -(data.normY - 0.5) * playAreaSize + playAreaOffsetY;
            const pos = new THREE.Vector3(xPos, yPos, 0);

            let color = 0x00ffcc;
            if (data.id === 'auto') color = 0xffaa00;
            else if (connectedUsers[data.id]) color = new THREE.Color(connectedUsers[data.id].color);

            const mesh = new THREE.Mesh(new THREE.RingGeometry(0.99, 1.0, 64), new THREE.MeshBasicMaterial({ 
                color: color, 
                transparent: true, 
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending 
            }));
            mesh.position.copy(pos);
            scene.add(mesh);
            visualObjects.push({ type: 'ring', mesh, startTime: Date.now(), duration: data.duration });

            if (prevNotePos && data.id !== 'auto') {
                const points = [prevNotePos.clone(), pos.clone()];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0.2, blending: THREE.AdditiveBlending });
                const line = new THREE.Line(geometry, material);
                scene.add(line);
                visualObjects.push({ type: 'line', mesh: line, startTime: Date.now(), duration: data.duration * 2.0 }); 
            }
            if(data.id !== 'auto') prevNotePos = pos;
        });

        const eqCanvas = document.getElementById('eq-canvas'); const eqCtx = eqCanvas.getContext('2d'); const eqReadout = document.getElementById('eq-readout');
        const minFreq = 20; const maxFreq = 20000;
        function xToFreq(x, width) { return minFreq * Math.pow(maxFreq / minFreq, x / width); }
        function freqToX(freq, width) { return (Math.log(freq / minFreq) / Math.log(maxFreq / minFreq)) * width; }
        function yToDb(y, height) { return 12 - (y / height) * 24; }
        function dbToY(db, height) { return height/2 - (db/24) * height; }
        
        function getEQResponse(f) {
            let db = 0;
            if (localEQ.low.gain !== 0) db += localEQ.low.gain * (1 / (1 + Math.pow(f / localEQ.low.freq, 4)));
            if (localEQ.high.gain !== 0) db += localEQ.high.gain * (1 / (1 + Math.pow(localEQ.high.freq / f, 4)));
            if (localEQ.mid.gain !== 0) { const Q=2.5; db += localEQ.mid.gain * Math.exp( -Math.pow( (Math.log(f/localEQ.mid.freq)) * Q, 2 ) ); }
            
            // ★Global LPF Curve
            const filterVal = localParams['FILTER'] !== undefined ? localParams['FILTER'] : 1.0;
            const cutoff = 100 * Math.pow(80, filterVal);
            if(cutoff < 19000) {
                const attenuation = 20 * Math.log10(1 / Math.sqrt(1 + Math.pow(f / cutoff, 4)));
                db += attenuation;
            }
            return db;
        }
        
        let draggingPoint = null;
        let lastEqSyncTime = 0;
        
        function drawEQ() {
            const w = eqCanvas.width; const h = eqCanvas.height; 
            eqCtx.clearRect(0, 0, w, h);
            if (fft) {
                const values = fft.getValue(); 
                const nyquist = Tone.context.sampleRate / 2;
                const fftSize = values.length;
                eqCtx.fillStyle = 'rgba(0, 255, 204, 0.15)'; 
                eqCtx.beginPath(); eqCtx.moveTo(0, h);
                for (let i = 0; i < fftSize; i++) {
                    const db = values[i]; if (db === -Infinity) continue;
                    const freq = i * (nyquist / fftSize); const x = freqToX(freq, w);
                    if (x < 0) continue; if (x > w) break; 
                    const barHeight = Math.max(0, (db + 100) / 100 * h);
                    eqCtx.lineTo(x, h - barHeight);
                }
                eqCtx.lineTo(w, h); eqCtx.fill();
            }
            eqCtx.strokeStyle = 'rgba(255,255,255,0.1)'; eqCtx.lineWidth = 1; eqCtx.beginPath();
            [100, 1000, 10000].forEach(f => { const x = freqToX(f, w); eqCtx.moveTo(x, 0); eqCtx.lineTo(x, h); });
            eqCtx.moveTo(0, h/2); eqCtx.lineTo(w, h/2); eqCtx.stroke();
            
            eqCtx.strokeStyle = '#00ffcc'; eqCtx.lineWidth = 2; eqCtx.beginPath();
            for (let x = 0; x < w; x+=2) { const y = dbToY(getEQResponse(xToFreq(x, w)), h); if (x === 0) eqCtx.moveTo(x, y); else eqCtx.lineTo(x, y); }
            eqCtx.stroke(); 
            
            [ {id:'low', c:'#ff0055'}, {id:'mid', c:'#ffff00'}, {id:'high', c:'#00ccff'} ].forEach(p => {
                const d = localEQ[p.id]; const x = freqToX(d.freq, w); const y = dbToY(d.gain, h);
                eqCtx.fillStyle = p.c; eqCtx.beginPath(); eqCtx.arc(x, y, 6, 0, Math.PI*2); eqCtx.fill();
                if(draggingPoint===p.id){ eqCtx.strokeStyle='#fff'; eqCtx.lineWidth=2; eqCtx.stroke(); }
            });
        }
        function handleEQMove(cx, cy, isDown) {
            const r = eqCanvas.getBoundingClientRect(); const x = Math.max(0, Math.min(r.width, cx - r.left)); const y = Math.max(0, Math.min(r.height, cy - r.top));
            if (isDown) {
                const pts = ['low','mid','high'].map(k => ({id:k, x:freqToX(localEQ[k].freq, r.width), y:dbToY(localEQ[k].gain, r.height)}));
                for(let p of pts) if(Math.hypot(p.x-x, p.y-y)<30) draggingPoint=p.id;
            }
            if (draggingPoint) {
                const f = xToFreq(x, r.width); const g = Math.max(-12, Math.min(12, yToDb(y, r.height)));
                localEQ[draggingPoint].freq=f; localEQ[draggingPoint].gain=g;
                if(eqLow){ 
                    if(draggingPoint==='low'){ eqLow.frequency.value=f; eqLow.gain.value=g; }
                    if(draggingPoint==='mid'){ eqMid.frequency.value=f; eqMid.gain.value=g; }
                    if(draggingPoint==='high'){ eqHigh.frequency.value=f; eqHigh.gain.value=g; }
                }
                eqReadout.textContent=`${draggingPoint.toUpperCase()}: ${Math.round(f)}Hz / ${g.toFixed(1)}dB`; 
                if (Date.now() - lastEqSyncTime > 30) { socket.emit('update_eq', localEQ); lastEqSyncTime = Date.now(); }
            }
        }
        function endEQDrag() { if(draggingPoint){ socket.emit('update_eq', localEQ); draggingPoint=null; eqReadout.textContent="DRAG POINTS"; }}
        eqCanvas.addEventListener('mousedown', e=>handleEQMove(e.clientX,e.clientY,true)); window.addEventListener('mousemove', e=>{if(draggingPoint)handleEQMove(e.clientX,e.clientY,false)}); window.addEventListener('mouseup', endEQDrag);
        eqCanvas.addEventListener('touchstart', e=>{e.preventDefault(); handleEQMove(e.touches[0].clientX,e.touches[0].clientY,true)},{passive:false}); window.addEventListener('touchmove', e=>{if(draggingPoint){e.preventDefault(); handleEQMove(e.touches[0].clientX,e.touches[0].clientY,false)}},{passive:false}); window.addEventListener('touchend', endEQDrag);
        
        const volSynth=document.getElementById('vol-synth');
        let lastMixerSync = 0;
        const updateMixer=(v)=>{
            localMixer=v; volSynth.value=v.synth; if(synth)synth.volume.value=v.synth; 
        };
        volSynth.addEventListener('input',()=>{ updateMixer({synth:parseFloat(volSynth.value)}); if(Date.now()-lastMixerSync>30){socket.emit('update_mixer',localMixer);lastMixerSync=Date.now();} }); 
        volSynth.addEventListener('change',()=>socket.emit('update_mixer',localMixer)); 
        volSynth.addEventListener('touchstart',ev=>ev.stopPropagation(),{passive:false}); 
        volSynth.addEventListener('mousedown',ev=>ev.stopPropagation());

        const waveCanvas=document.getElementById('wave-canvas'), waveCtx=waveCanvas.getContext('2d'), resetBtn=document.getElementById('reset-btn');
        const WAVE_SIZE=128; let waveBuffer=new Array(WAVE_SIZE).fill(0).map((_,i)=>Math.sin((i/WAVE_SIZE)*Math.PI*2));
        let lastWaveSync = 0;
        function drawWave(b){ 
            const w=waveCanvas.width, h=waveCanvas.height, c=h/2;
            waveCtx.clearRect(0,0,w,h); waveCtx.strokeStyle='#333'; waveCtx.beginPath(); waveCtx.moveTo(0,c); waveCtx.lineTo(w,c); waveCtx.stroke(); 
            waveCtx.beginPath(); waveCtx.strokeStyle='#00ffcc'; waveCtx.lineWidth=2; 
            for(let i=0;i<WAVE_SIZE;i++){ const x=(i/(WAVE_SIZE-1))*w, y=c-(b[i]*(h/2)); if(i===0)waveCtx.moveTo(x,y); else waveCtx.lineTo(x,y); } 
            waveCtx.stroke(); waveCtx.lineTo(w,c); waveCtx.lineTo(0,c); waveCtx.fillStyle='rgba(0, 255, 204, 0.1)'; waveCtx.fill(); 
        }
        let isDrawingWave=false;
        function updateWave(cx,cy){ 
            const r=waveCanvas.getBoundingClientRect(); const nx=Math.max(0,Math.min(1,(cx-r.left)/r.width)), ny=-((Math.max(0,Math.min(1,(cy-r.top)/r.height))*2)-1);
            const idx=Math.floor(nx*(WAVE_SIZE-1)); if(idx>=0&&idx<WAVE_SIZE) waveBuffer[idx]=ny; 
            drawWave(waveBuffer); updateSynthWave(waveBuffer);
            if(Date.now() - lastWaveSync > 30) { socket.emit('update_waveform', waveBuffer); lastWaveSync = Date.now(); }
        }
        const handleWaveStart = e => { isDrawingWave = true; if(e.type === 'mousedown') handleWaveMove(e); else if(e.type === 'touchstart') { e.preventDefault(); const t = e.touches[0]; updateWave(t.clientX, t.clientY); } }; 
        const handleWaveEnd = () => { if(isDrawingWave){isDrawingWave=false; socket.emit('update_waveform',waveBuffer)} }; 
        const handleWaveMove = e => { if(!isDrawingWave) return; e.preventDefault(); const t = e.touches ? e.touches[0] : e; updateWave(t.clientX, t.clientY); };
        waveCanvas.addEventListener('mousedown', handleWaveStart); window.addEventListener('mouseup', handleWaveEnd); waveCanvas.addEventListener('mousemove', handleWaveMove);
        waveCanvas.addEventListener('touchstart', handleWaveStart, {passive: false}); window.addEventListener('touchend', handleWaveEnd); waveCanvas.addEventListener('touchmove', handleWaveMove, {passive: false});
        resetBtn.addEventListener('click', e=>{e.stopPropagation(); waveBuffer=waveBuffer.map((_,i)=>Math.sin((i/WAVE_SIZE)*Math.PI*2)); drawWave(waveBuffer); updateSynthWave(waveBuffer); socket.emit('update_waveform',waveBuffer)});
        resetBtn.addEventListener('touchstart', e=>e.stopPropagation(),{passive:false});

        const slA=document.getElementById('adsr-a'), slD=document.getElementById('adsr-d'), slS=document.getElementById('adsr-s'), slR=document.getElementById('adsr-r');
        let lastAdsrSync = 0;
        function drawADSRVisual(){ 
            const w=adsrC.width, h=adsrC.height;
            adsrCtx.clearRect(0,0,w,h); adsrCtx.fillStyle='rgba(0,0,0,0.3)'; adsrCtx.fillRect(0,0,w,h);
            const A=parseFloat(slA.value), D=parseFloat(slD.value), S=parseFloat(slS.value), R=parseFloat(slR.value);
            adsrCtx.beginPath(); adsrCtx.strokeStyle='#00ffcc'; adsrCtx.lineWidth=2;
            const x1=(A/2)*(w*0.25), y2=h-(S*h), x2=x1+(D/2)*(w*0.25), x3=x2+(w*0.2), x4=Math.min(w,x3+(R/5)*(w*0.3));
            adsrCtx.moveTo(0,h); adsrCtx.lineTo(x1,0); adsrCtx.lineTo(x2,y2); adsrCtx.lineTo(x3,y2); adsrCtx.lineTo(x4,h); adsrCtx.stroke();
        }
        
        // Manual ADSR update
        const updateManualADSR=()=>{ 
            // 値を取得してローカルパラメータも更新
            const a=parseFloat(slA.value), d=parseFloat(slD.value), s=parseFloat(slS.value), r=parseFloat(slR.value);
            localADSR={attack:a,decay:d,sustain:s,release:r}; 
            
            // サーバーへ個別送信 (スライダー動かした時は個別パラメータ更新として扱うべきか、ADSR全体か)
            // ここでは従来通り全体更新イベントを使うが、パラメータ同期とも矛盾しないように注意
            // ※今回はADSRはセンサー操作がメインだが、手動操作も残す
            drawADSRVisual(); 
            if(synth)synth.set({envelope:localADSR}); 
            // Broadcast is optional here or handled via separate event. 
            // To keep simple, we don't broadcast manual slider moves as 'sensor param' but as 'adsr update'
            // The previous logic used 'update_adsr' which broadcasts whole object.
            if(Date.now() - lastAdsrSync > 30) { socket.emit('update_adsr',localADSR); lastAdsrSync = Date.now(); }
        };
        [slA,slD,slS,slR].forEach(s=>{ s.addEventListener('input',updateManualADSR); s.addEventListener('change',()=>socket.emit('update_adsr',localADSR)); s.addEventListener('touchstart',e=>e.stopPropagation(),{passive:false}); s.addEventListener('mousedown',e=>e.stopPropagation()) });

        const scaleBtns = document.querySelectorAll('.scale-btn');
        scaleBtns.forEach(btn => {
            btn.addEventListener('click', (e) => { e.stopPropagation(); socket.emit('update_scale', btn.dataset.scale); });
            btn.addEventListener('touchstart', e=>e.stopPropagation(), {passive:false});
        });

        // --- Auto Play UI ---
        const autoBtn = document.getElementById('auto-btn');
        const autoSpeed = document.getElementById('auto-speed');
        let lastAutoSync = 0;

        function updateAutoUI() {
            if(localAuto.active) {
                autoBtn.textContent = "AUTO: ON";
                autoBtn.classList.add("active");
            } else {
                autoBtn.textContent = "AUTO: OFF";
                autoBtn.classList.remove("active");
            }
            autoSpeed.value = localAuto.speed;
        }

        autoBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            localAuto.active = !localAuto.active;
            socket.emit('update_auto', localAuto);
            updateAutoUI();
        });
        autoBtn.addEventListener('touchstart', (e) => e.stopPropagation(), {passive: false});

        autoSpeed.addEventListener('input', () => {
            localAuto.speed = parseInt(autoSpeed.value);
            if(Date.now() - lastAutoSync > 100) { 
                socket.emit('update_auto', localAuto);
                lastAutoSync = Date.now();
            }
        });
        autoSpeed.addEventListener('change', () => {
            socket.emit('update_auto', localAuto);
        });
        autoSpeed.addEventListener('touchstart', (e) => e.stopPropagation(), {passive: false});
        autoSpeed.addEventListener('mousedown', (e) => e.stopPropagation());

        let isPointerDown = false; let lastMoveNoteTime = 0; const MOVE_NOTE_INTERVAL = 100;
        function triggerNoteFromInput(normX, normY) {
            if (normX < 0 || normX > 1 || normY < 0 || normY > 1) return;
            const scaleNotes = SCALES[currentScaleName]; const noteIndex = Math.floor((1 - normY) * scaleNotes.length);
            const note = scaleNotes[Math.min(noteIndex, scaleNotes.length - 1)];
            socket.emit('play_note', { note, duration: 0.5 + normX * 4.0, normX, normY });
        }
        function handleInput(e, isMove) {
            if (!isStarted) return;
            const target = e.target;
            if (['INPUT', 'BUTTON'].includes(target.tagName)) return;
            if (['wave-canvas','adsr-canvas','eq-canvas'].includes(target.id)) return;
            const cX = e.touches ? e.touches[0].clientX : e.clientX;
            const cY = e.touches ? e.touches[0].clientY : e.clientY;
            const controlsRect = document.getElementById('controls').getBoundingClientRect();
            if (controlsRect.top <= cY) return;
            const w = window.innerWidth; const h = window.innerHeight;
            const centerX = w / 2; const centerY = (h / 2) - playAreaOffsetY;
            const normX = ((cX - centerX) / playAreaSize) + 0.5;
            const normY = ((cY - centerY) / playAreaSize) + 0.5;
            if (isMove) {
                const now = Date.now();
                if (now - lastMoveNoteTime > MOVE_NOTE_INTERVAL) { triggerNoteFromInput(normX, normY); lastMoveNoteTime = now; }
            } else { triggerNoteFromInput(normX, normY); lastMoveNoteTime = Date.now(); }
        }
        function onPointerDown(e) { isPointerDown = true; handleInput(e, false); }
        function onPointerMove(e) { 
            if (isPointerDown) {
                const target = e.target;
                const inControls = document.getElementById('controls').contains(target);
                if (!inControls) { e.preventDefault(); handleInput(e, true); }
            }
        }
        function onPointerUp() { isPointerDown = false; prevNotePos = null; }
        window.addEventListener('mousedown', onPointerDown); window.addEventListener('mousemove', onPointerMove); window.addEventListener('mouseup', onPointerUp);
        window.addEventListener('touchstart', onPointerDown, {passive: false}); window.addEventListener('touchmove', onPointerMove, {passive: false}); window.addEventListener('touchend', onPointerUp);
    </script>
</body>
</html>
