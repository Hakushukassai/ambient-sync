<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Synth Master Sync v4 - Gravity Update</title>
    <style>
        /* --- Base Aesthetic --- */
        body { margin: 0; overflow: hidden; background: #050505; touch-action: none; color: #ccc; font-family: 'Helvetica Neue', Arial, sans-serif; letter-spacing: 0.05em; }
        
        /* Ghost Pulse */
        @keyframes pulse-border {
            0% { border-color: #333; box-shadow: 0 0 0 rgba(0,0,0,0); }
            50% { border-color: #777; box-shadow: 0 0 10px rgba(255,255,255,0.05); }
            100% { border-color: #333; box-shadow: 0 0 0 rgba(0,0,0,0); }
        }
        .ghost-pulse { animation: pulse-border 0.3s ease-out; }

        /* --- Controls Container --- */
        #controls {
            position: fixed; bottom: 0; left: 0; width: 100%; height: 300px;
            background: rgba(10, 10, 10, 0.95);
            border-top: 1px solid #222;
            display: flex; flex-direction: row; justify-content: flex-start; align-items: center;
            padding-bottom: 20px; z-index: 50; gap: 15px; box-sizing: border-box;
            overflow-x: auto; touch-action: pan-x; -webkit-overflow-scrolling: touch;
        }
        #controls::-webkit-scrollbar { display: none; }
        
        /* --- PC View Enhancements --- */
        @media (min-width: 1024px) { 
            body { background: #080808; }
            
            /* 修正: justify-contentを左寄せにし、スクロール(auto)を許可 */
            #controls { 
                justify-content: flex-start; 
                overflow-x: auto; 
                background: #111; 
                height: 320px; 
            } 

            /* 追加: PCではスクロールバーを表示して操作しやすくする（デザインに合わせる） */
            #controls::-webkit-scrollbar { display: block; height: 8px; }
            #controls::-webkit-scrollbar-track { background: #111; }
            #controls::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
            #controls::-webkit-scrollbar-thumb:hover { background: #555; }

            .panel-section { border: 1px solid #444 !important; background: #161616 !important; }
            canvas { border: 1px solid #555 !important; background: #000 !important; }
            .label { color: #888 !important; font-weight: bold; }
            .param-label { color: #aaa !important; }
            button { border-color: #555 !important; color: #aaa !important; }
        }

        .panel-section {
            display: flex; flex-direction: column; align-items: center;
            background: #0a0a0a; border: 1px solid #222; border-radius: 4px;
            padding: 12px; width: 250px; height: 230px;
            justify-content: flex-start; 
            flex-shrink: 0; position: relative; scroll-snap-align: center;
            transition: border-color 0.2s;
        }
        
        .label { font-size: 10px; color: #555; margin-bottom: 10px; letter-spacing: 1px; width: 100%; text-align: left; }

        canvas { background: #000; border: 1px solid #222; border-radius: 2px; touch-action: none; }
        #wave-canvas { height: 80px; cursor: crosshair; }
        #eq-canvas { height: 90px; cursor: default; }
        #adsr-canvas { height: 60px; }

        .eq-values { font-size: 9px; color: #444; width: 100%; text-align: center; margin-top: 5px; pointer-events: none; }
        
        /* Mixer Container Alignment Fix */
        .mixer-container { 
            display: flex; gap: 20px; 
            height: auto; flex-grow: 1;
            align-items: center; justify-content: center; width: 100%; 
            margin-top: -10px; 
        }
        #adsr-container { display: flex; flex-direction: column; align-items: center; width: 100%; }
        
        /* Sliders Layout */
        .sliders { display: flex; gap: 2px; width: 100%; justify-content: space-between; margin-top: 10px; height: 100px; }
        
        .slider-group { 
            display: flex; flex-direction: column; align-items: center; flex: 1; 
            height: auto; justify-content: center; 
            position: relative; min-height: 110px;
        }
        
        .slider-wrapper {
            width: 30px; height: 80px;
            display: flex; align-items: center; justify-content: center;
            margin-bottom: 5px;
        }

        input[type=range].vertical {
            -webkit-appearance: none; appearance: none;
            width: 80px; height: 30px;
            background: transparent;
            transform: rotate(-90deg);
            cursor: pointer; margin: 0;
        }

        input[type=range].vertical::-webkit-slider-runnable-track { width: 100%; height: 4px; background: #222; border-radius: 2px; border: none; }
        input[type=range].vertical::-moz-range-track { width: 100%; height: 4px; background: #222; border-radius: 2px; border: none; }

        input[type=range].vertical::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 8px; height: 16px;
            background: #ccc; border: 1px solid #fff; border-radius: 2px;
            margin-top: -6px; 
            box-shadow: 0 0 5px rgba(255,255,255,0.2);
        }

        .param-label { 
            font-size: 8px; color: #555; margin-top: 2px; text-align: center; 
            white-space: nowrap; width: 100%; position: absolute; bottom: 0;
        }
        
        /* Value Display Style */
        .val-display {
            font-size: 9px; color: #00d2ff; text-align: center; width: 100%;
            position: absolute; top: 0; font-family: 'Courier New', monospace;
            text-shadow: 0 0 2px rgba(0, 210, 255, 0.3);
        }

        .btn-group { display: flex; gap: 5px; margin-top: 15px; width: 100%; }
        button {
            background: #111; border: 1px solid #333;
            color: #666; font-size: 9px; padding: 6px 0; flex: 1; cursor: pointer; border-radius: 2px;
            font-family: inherit; transition: all 0.2s;
        }
        button:hover { background: #222; color: #fff; }
        button.active { background: #eee; color: #000; border-color: #fff; font-weight: bold; }
        button.ghost-active { background: #220033; color: #eebbff; border-color: #aa44ff; }

        .scale-grid { 
            display: grid; grid-template-columns: 1fr 1fr; gap: 4px; width: 100%; margin-top: 5px; height: 100%; 
            overflow-y: auto; align-content: start; 
        }
        .scale-btn { 
            padding: 8px 6px; font-size: 9px; text-align: left; width: 100%; 
            border: 1px solid #222; background: #111; color: #666;
        }
        .scale-btn.active { border-color: #888; background: #333; color: #fff; }

        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            cursor: pointer; letter-spacing: 4px; color: #fff; font-weight: 300;
        }
        #overlay span { margin-top: 20px; font-size: 10px; color: #555; letter-spacing: 2px; }

        #sensor-btn, #mode-btn {
            position: fixed; top: 20px; z-index: 100;
            background: rgba(0,0,0,0.5); border: 1px solid #444; color: #888;
            padding: 8px 16px; font-size: 9px; border-radius: 100px; cursor: pointer;
            backdrop-filter: blur(5px); transition: all 0.3s;
        }
        #sensor-btn { right: 20px; }
        #mode-btn { left: 20px; }
        #sensor-btn.active { color: #fff; border-color: #fff; background: rgba(255,255,255,0.2); }
        #mode-btn.physics { color: #fff; border-color: #fff; background: rgba(255,255,255,0.2); }

        #scale-display { position: fixed; bottom: 20px; right: 20px; font-size: 10px; color: #444; z-index: 9999; pointer-events: none; }
        #version-display { position: fixed; bottom: 5px; right: 20px; font-size: 9px; color: #222; z-index: 9999; pointer-events: none; }

        /* Sensor Meters */
        #sensor-panel { position: fixed; top: 70px; right: 20px; z-index: 90; display: flex; gap: 8px; }
        .sensor-group { display: flex; flex-direction: column; align-items: center; gap: 4px; }
        .sensor-meter {
            width: 4px; height: 60px; background: #111;
            border-radius: 2px; position: relative; overflow: hidden;
            display: flex; flex-direction: column-reverse; border: 1px solid #222;
        }
        .sensor-fill { width: 100%; height: 0%; background: #666; transition: height 0.1s; }
        .target-btn { font-size: 8px; color: #666; background: transparent; border: none; padding: 2px; width: 40px; text-align: center; cursor: pointer; }
    </style>
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    
    <div id="overlay">
        <div>TAP TO START</div>
        <span>AUDIO & VISUAL SYNC</span>
    </div>

    <div id="scale-display">SCALE: LOADING...</div>
    <div id="version-display">v3.1.0 - Lifespan & Sync Fix</div>

    <button id="mode-btn">MODE: TOUCH</button>
    <button id="sensor-btn">SENSOR: OFF</button>
    
    <div id="sensor-panel">
        <div class="sensor-group">
            <div class="sensor-meter"><div class="sensor-fill" id="fill-x"></div></div>
            <button class="target-btn" id="target-x-btn">FILT</button>
        </div>
        <div class="sensor-group">
            <div class="sensor-meter"><div class="sensor-fill" id="fill-y"></div></div>
            <button class="target-btn" id="target-y-btn">REV</button>
        </div>
    </div>

    <div id="controls">
        <div class="panel-section" id="panel-wave" style="width: 280px;"> <div class="label">1. OSCILLATOR & UNISON</div>
            <div style="display: flex; gap: 10px; width: 100%; justify-content: center; align-items: center;">
                <canvas id="wave-canvas" width="160" height="80"></canvas>
                <div style="display: flex; gap: 4px;">
                    <div class="slider-group">
                        <div class="val-display" id="disp-uni-voices">3</div>
                        <div class="slider-wrapper"><input type="range" class="vertical" id="uni-voices" min="1" max="5" step="1" value="3"></div>
                        <span class="param-label">VOICE</span>
                    </div>
                    <div class="slider-group">
                        <div class="val-display" id="disp-uni-spread">30</div>
                        <div class="slider-wrapper"><input type="range" class="vertical" id="uni-spread" min="0" max="100" step="1" value="30"></div>
                        <span class="param-label">SPRD</span>
                    </div>
                </div>
            </div>
            <div class="btn-group">
                <button id="reset-btn">RESET</button>
                <button id="auto-note-btn">NOTES: OFF</button>
                <button id="auto-drift-btn">GHOST: OFF</button>
            </div>
        </div>

        <div class="panel-section" id="panel-eq">
            <div class="label">2. SPECTRUM & EQ</div>
            <div id="eq-container" style="width:100%; height:100%; display:flex; flex-direction:column; align-items:center; justify-content:center;">
                <canvas id="eq-canvas" width="224" height="90"></canvas>
                <div class="eq-values" id="eq-readout">DRAG</div>
            </div>
        </div>

        <div class="panel-section" id="panel-mix">
            <div class="label">3. MIXER</div>
            <div class="mixer-container">
                <div class="slider-group">
                    <div class="val-display" id="disp-vol-synth">-6dB</div>
                    <div class="slider-wrapper"><input type="range" class="vertical" id="vol-synth" min="-60" max="0" step="1" value="-6"></div>
                    <span class="param-label">VOL</span>
                </div>
                <div class="slider-group">
                    <div class="val-display" id="disp-auto-speed">30%</div>
                    <div class="slider-wrapper"><input type="range" class="vertical" id="auto-speed" min="0" max="100" step="1" value="30"></div>
                    <span class="param-label">SPEED</span>
                </div>
            </div>
        </div>

        <div class="panel-section" id="panel-adsr">
            <div class="label">4. ENVELOPE</div>
            <div id="adsr-container">
                <canvas id="adsr-canvas" width="224" height="60"></canvas>
                <div class="sliders">
                    <div class="slider-group">
                        <div class="val-display" id="disp-adsr-a">0.1s</div>
                        <div class="slider-wrapper"><input type="range" class="vertical" id="adsr-a" min="0.01" max="2.0" step="0.01" value="0.1"></div>
                        <span class="param-label">A</span>
                    </div>
                    <div class="slider-group">
                        <div class="val-display" id="disp-adsr-d">0.2s</div>
                        <div class="slider-wrapper"><input type="range" class="vertical" id="adsr-d" min="0.1" max="2.0" step="0.01" value="0.2"></div>
                        <span class="param-label">D</span>
                    </div>
                    <div class="slider-group">
                        <div class="val-display" id="disp-adsr-s">50%</div>
                        <div class="slider-wrapper"><input type="range" class="vertical" id="adsr-s" min="0" max="1.0" step="0.01" value="0.5"></div>
                        <span class="param-label">S</span>
                    </div>
                    <div class="slider-group">
                        <div class="val-display" id="disp-adsr-r">1.5s</div>
                        <div class="slider-wrapper"><input type="range" class="vertical" id="adsr-r" min="0.1" max="5.0" step="0.1" value="1.5"></div>
                        <span class="param-label">R</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="panel-section" id="panel-fx">
            <div class="label">5. EFFECTS</div>
            <div class="sliders">
                <div class="slider-group">
                    <div class="val-display" id="disp-fx-filter">50%</div>
                    <div class="slider-wrapper"><input type="range" class="vertical" id="fx-filter" min="0" max="1" step="0.01" value="0.5"></div>
                    <span class="param-label">FILT</span>
                </div>
                <div class="slider-group">
                    <div class="val-display" id="disp-fx-reverb">0%</div>
                    <div class="slider-wrapper"><input type="range" class="vertical" id="fx-reverb" min="0" max="1" step="0.01" value="0.0"></div>
                    <span class="param-label">REV</span>
                </div>
                <div class="slider-group">
                    <div class="val-display" id="disp-fx-delay-mix">0%</div>
                    <div class="slider-wrapper"><input type="range" class="vertical" id="fx-delay-mix" min="0" max="1" step="0.01" value="0.0"></div>
                    <span class="param-label">D.MIX</span>
                </div>
                <div class="slider-group">
                    <div class="val-display" id="disp-fx-delay-fb">30%</div>
                    <div class="slider-wrapper"><input type="range" class="vertical" id="fx-delay-fb" min="0" max="1" step="0.01" value="0.3"></div>
                    <span class="param-label">D.FB</span>
                </div>
                <div class="slider-group">
                    <div class="val-display" id="disp-fx-pan">C</div>
                    <div class="slider-wrapper"><input type="range" class="vertical" id="fx-pan" min="0" max="1" step="0.01" value="0.5"></div>
                    <span class="param-label">PAN</span>
                </div>
            </div>
        </div>

        <div class="panel-section" id="panel-scale">
            <div class="label">6. SCALE</div>
            <div class="scale-grid">
                <button class="scale-btn" data-scale="MYSTERIOUS">MYST</button>
                <button class="scale-btn active" data-scale="MINOR_PENTATONIC">M.PENT</button>
                <button class="scale-btn" data-scale="MAJOR">MAJOR</button>
                <button class="scale-btn" data-scale="MINOR">MINOR</button>
                <button class="scale-btn" data-scale="DORIAN">DORIAN</button>
                <button class="scale-btn" data-scale="LYDIAN">LYDIAN</button>
                <button class="scale-btn" data-scale="RYUKYU">RYUKYU</button>
                <button class="scale-btn" data-scale="MIYAKOBUSHI">MIYAKO</button>
                <button class="scale-btn" data-scale="WHOLE_TONE">WHOLE</button>
            </div>
        </div>

        <div class="panel-section" id="panel-physics" style="width: 300px;">
            <div class="label">7. PHYSICS & TIME</div>
            <div class="mixer-container">
                <div class="slider-group">
                    <div class="val-display" id="disp-phys-grav-y">Low</div>
                    <div class="slider-wrapper"><input type="range" class="vertical" id="phys-grav-y" min="-0.02" max="0.02" step="0.0001" value="0.005"></div>
                    <span class="param-label">GRAV.Y</span>
                </div>
                <div class="slider-group">
                    <div class="val-display" id="disp-phys-grav-x">0</div>
                    <div class="slider-wrapper"><input type="range" class="vertical" id="phys-grav-x" min="0" max="1" step="0.01" value="0.5"></div>
                    <span class="param-label">GRAV.X</span>
                </div>
                <div class="slider-group">
                    <div class="val-display" id="disp-phys-life">5.0s</div>
                    <div class="slider-wrapper"><input type="range" class="vertical" id="phys-life" min="0.01" max="1.0" step="0.01" value="0.5"></div>
                    <span class="param-label">LIFE</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const socket = io();
        let isStarted = false;
        let physicsMode = false; 
        
        let synth, limiter, chorus, reverb, pingPong, fft, panner, compressor; 
        let eqLow, eqMid, eqHigh, globalFilter; 

        // --- Layout & Device Detection ---
        let playAreaSize = 0;
        let playAreaMesh;
        let playAreaOffsetY = 0; 
        let prevNotePos = null;
        const isPC = window.innerWidth >= 1024; 

        // --- Visuals & Physics ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(isPC ? 0x080808 : 0x050505, 0.05);

        const width = window.innerWidth;
        const height = window.innerHeight;
        const camera = new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, 1, 1000);
        camera.position.z = 10;
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(width, height);
        renderer.domElement.id = 'main-canvas';
        document.body.appendChild(renderer.domElement);

        let sensorCursor;
        let cursorTargetPos = { x: 0, y: 0 };
        let meterTargetVal = { x: 0, y: 0 };
        let meterCurrentVal = { x: 0, y: 0 };
        
        const balls = [];
        let localPhysics = { x: 0, y: 0.005, lifespanMs: 5000 }; 
        const BOUNCE_DAMPING = 0.7; 
        const HIT_COOLDOWN = 100; // ms

        const cursorGeo = new THREE.RingGeometry(0.8, 1.0, 32); 
        const cursorMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: isPC ? 0.6 : 0.3 });
        sensorCursor = new THREE.Mesh(cursorGeo, cursorMat);
        scene.add(sensorCursor);
        
        const forceFieldGeo = new THREE.RingGeometry(0.95, 1.0, 64);
        const forceFieldMat = new THREE.MeshBasicMaterial({ color: 0xaaccff, transparent: true, opacity: 0.0, side: THREE.DoubleSide, blending: THREE.AdditiveBlending });
        const forceFieldMesh = new THREE.Mesh(forceFieldGeo, forceFieldMat);
        scene.add(forceFieldMesh);

        function updateLayout() {
            const w = window.innerWidth; const h = window.innerHeight;
            const controlsEl = document.getElementById('controls');
            const controlsHeight = controlsEl ? controlsEl.offsetHeight : 0;
            const availableHeight = h - controlsHeight;
            playAreaSize = Math.min(w, availableHeight) * 0.9;
            playAreaOffsetY = controlsHeight / 2;
            camera.left = w / -2; camera.right = w / 2;
            camera.top = h / 2; camera.bottom = h / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(w, h);
            if (playAreaMesh) scene.remove(playAreaMesh);
            
            const lineColor = isPC ? 0x666666 : 0x333333;
            const borderGeo = new THREE.EdgesGeometry(new THREE.PlaneGeometry(playAreaSize, playAreaSize));
            const borderMat = new THREE.LineBasicMaterial({ color: lineColor });
            playAreaMesh = new THREE.LineSegments(borderGeo, borderMat);
            playAreaMesh.position.y = playAreaOffsetY;
            scene.add(playAreaMesh);

            if(sensorCursor) {
                const s = playAreaSize * 0.04;
                sensorCursor.scale.set(s, s, s);
                sensorCursor.position.y = playAreaOffsetY + cursorTargetPos.y; 
            }
            resizeCanvases();
        }
        function resizeCanvases() {
            const wCanvas = document.getElementById('wave-canvas');
            const eCanvas = document.getElementById('eq-canvas');
            const aCanvas = document.getElementById('adsr-canvas');
            wCanvas.width = 160; wCanvas.height = 80;
            eCanvas.width = 224; eCanvas.height = 90;
            aCanvas.width = 224; aCanvas.height = 60;
            drawWave(waveBuffer); 
            drawADSRVisual();
        }
        window.addEventListener('resize', () => {
            if (Math.abs(window.innerWidth - width) > 100) location.reload();
            updateLayout();
        });
        setTimeout(updateLayout, 100);

        const visualObjects = []; 
        let lastFrameTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);
            
            const nowPerf = performance.now();
            const nowTime = Date.now();
            const delta = Math.min((nowPerf - lastFrameTime) / 16.667, 4.0);
            lastFrameTime = nowPerf;

            if(isStarted) drawEQ();

            const lerpFactor = 0.1 * delta;
            if(sensorCursor) {
                const targetY = cursorTargetPos.y + playAreaOffsetY;
                sensorCursor.position.x += (cursorTargetPos.x - sensorCursor.position.x) * lerpFactor;
                sensorCursor.position.y += (targetY - sensorCursor.position.y) * lerpFactor;
            }

            meterCurrentVal.x += (meterTargetVal.x - meterCurrentVal.x) * lerpFactor;
            meterCurrentVal.y += (meterTargetVal.y - meterCurrentVal.y) * lerpFactor;
            
            if(Math.abs(meterTargetVal.x - meterCurrentVal.x) > 0.001) fillX.style.height = (meterCurrentVal.x * 100) + "%";
            if(Math.abs(meterTargetVal.y - meterCurrentVal.y) > 0.001) fillY.style.height = (meterCurrentVal.y * 100) + "%";

            // Physics Update
            let forceNormPos = null;
            if (physicsMode && isPointerDown && currentPointerPos) {
                 const cx = (currentPointerPos.x - window.innerWidth/2);
                 const cy = -(currentPointerPos.y - window.innerHeight/2) + playAreaOffsetY;
                 const nx = (cx / playAreaSize) + 0.5;
                 const ny = (cy / playAreaSize) + 0.5;
                 forceNormPos = { x: nx, y: ny };
                 forceFieldMesh.position.set(cx, cy - playAreaOffsetY, 0); 
                 const pulse = 1.0 + Math.sin(nowTime * 0.01) * 0.1;
                 forceFieldMesh.scale.set(playAreaSize*0.15*pulse, playAreaSize*0.15*pulse, 1);
                 forceFieldMesh.material.opacity = 0.4; 
            } else {
                 forceFieldMesh.material.opacity = 0;
            }

            for (let i = balls.length - 1; i >= 0; i--) {
                const b = balls[i];
                
                // Lifespan check
                if (nowTime - b.spawnTime > localPhysics.lifespanMs) {
                    scene.remove(b.mesh);
                    balls.splice(i, 1);
                    continue;
                }

                // Gravity & Wind
                b.vy -= localPhysics.y * delta;
                const windForce = (localPhysics.x - 0.5) * 0.001; 
                b.vx = (b.vx || 0) + windForce * delta;
                
                // Force Field
                if (forceNormPos) {
                    const dx = b.x - forceNormPos.x;
                    const dy = b.y - forceNormPos.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 0.2) {
                        const force = (0.2 - dist) * 0.08 * delta;
                        b.vx = (b.vx || 0) + (dx / dist) * force;
                        b.vy += (dy / dist) * force;
                    }
                }
                
                b.x += (b.vx || 0) * delta;
                b.vx = (b.vx || 0) * Math.pow(0.99, delta);
                b.y += b.vy * delta;

                // Sound Trigger Helper with Debounce
                const tryPlay = (ball, velocity) => {
                    if (nowTime - ball.lastHit > HIT_COOLDOWN) {
                        triggerNoteFromPhysics(ball.x, velocity);
                        ball.lastHit = nowTime;
                        return true;
                    }
                    return false;
                };

                // Collision Logic
                if (b.x > 1.0) { 
                    b.x = 1.0; b.vx *= -1; 
                    tryPlay(b, Math.abs(b.vx) * 10.0);
                }
                if (b.x < 0.0) { 
                    b.x = 0.0; b.vx *= -1; 
                    tryPlay(b, Math.abs(b.vx) * 10.0);
                }
                if (b.y > 1.0) {
                    b.y = 1.0; b.vy *= -BOUNCE_DAMPING;
                    tryPlay(b, Math.abs(b.vy) * 10.0);
                }
                if (b.y < 0.0) {
                    b.y = 0.0; b.vy *= -BOUNCE_DAMPING;
                    tryPlay(b, Math.abs(b.vy) * 10.0);
                }
                
                const pixelX = (b.x - 0.5) * playAreaSize;
                const pixelY = (b.y - 0.5) * playAreaSize + playAreaOffsetY;
                b.mesh.position.set(pixelX, pixelY, 0);
                
                // Fade out
                const lifeProgress = (nowTime - b.spawnTime) / localPhysics.lifespanMs;
                if(lifeProgress > 0.8) {
                    b.mesh.material.opacity = 1.0 - ((lifeProgress - 0.8) * 5.0);
                    b.mesh.material.transparent = true;
                }
            }

            const visualNow = Date.now();
            for (let i = visualObjects.length - 1; i >= 0; i--) {
                const obj = visualObjects[i];
                const progress = (visualNow - obj.startTime) / (obj.duration * 1000);
                if (progress >= 1) {
                    scene.remove(obj.mesh);
                    visualObjects.splice(i, 1);
                } else {
                    if(obj.type === 'ring') {
                        const scale = (playAreaSize * 0.01) + (progress * playAreaSize * 0.5);
                        obj.mesh.scale.set(scale, scale, 1);
                        obj.mesh.material.opacity = (1 - progress) * 0.5; 
                    } else if (obj.type === 'line') {
                        obj.mesh.material.opacity = (1 - progress) * 0.15;
                    }
                }
            }
            renderer.render(scene, camera);
        }
        animate();

        function triggerGlitch(targetParam) {
            let panelId = null;
            if (['FILTER', 'PAN', 'REVERB', 'DELAY_FB', 'DELAY_MIX'].includes(targetParam)) panelId = 'panel-fx';
            else if (['VOL', 'FREQ'].includes(targetParam)) panelId = 'panel-mix';
            else if (['DECAY', 'RELEASE'].includes(targetParam)) panelId = 'panel-adsr';
            else if (['WAVE', 'UNISON_SPREAD'].includes(targetParam)) panelId = 'panel-wave'; 
            else if (['GRAVITY_X', 'GRAVITY_Y', 'PHYSICS_LIFESPAN'].includes(targetParam)) panelId = 'panel-physics';

            if (panelId) {
                const el = document.getElementById(panelId);
                if (el) {
                    el.classList.remove('ghost-pulse');
                    void el.offsetWidth;
                    el.classList.add('ghost-pulse');
                }
            }
        }

        // --- Audio & State ---
        let localADSR = { attack: 0.1, decay: 0.2, sustain: 0.5, release: 1.5 };
        let localMixer = { synth: -4 };
        let localEQ = { low: {freq:100, gain:4}, mid: {freq:1000, gain:-2}, high: {freq:5000, gain:-6} };
        let localAutoNote = { active: false, speed: 30 };
        let localAutoDrift = { active: false };
        const WAVE_SIZE=128; 
        let waveBuffer=new Array(WAVE_SIZE).fill(0).map((_,i)=>Math.sin((i/WAVE_SIZE)*Math.PI*2));

        const NOTE_NAMES = ["C", "Db", "D", "Eb", "E", "F", "F#", "G", "Ab", "A", "Bb", "B"];
        const SCALE_DEFINITIONS = {
            "MYSTERIOUS":       [0, 2, 3, 6, 7, 8, 11],
            "MINOR_PENTATONIC": [0, 3, 5, 7, 10], 
            "MAJOR":            [0, 2, 4, 5, 7, 9, 11],
            "MINOR":            [0, 2, 3, 5, 7, 8, 10],
            "DORIAN":           [0, 2, 3, 5, 7, 9, 10],
            "LYDIAN":           [0, 2, 4, 6, 7, 9, 11],
            "RYUKYU":           [0, 4, 5, 7, 11],
            "MIYAKOBUSHI":      [0, 1, 5, 7, 8],
            "WHOLE_TONE":       [0, 2, 4, 6, 8, 10]
        };
        const SCALES = {};
        for (const [name, intervals] of Object.entries(SCALE_DEFINITIONS)) {
            const notes = [];
            for (let oct = 2; oct <= 7; oct++) {
                for (let i = 0; i < 12; i++) {
                    if (intervals.includes(i)) {
                        if (oct === 7 && i > 0) break;
                        notes.push(NOTE_NAMES[i] + oct);
                    }
                }
            }
            SCALES[name] = notes;
        }
        let currentScaleName = "MYSTERIOUS"; 
        const scaleDisplay = document.getElementById('scale-display');

        async function initAudio() {
            if (isStarted) return;
            await Tone.start();
            
            fft = new Tone.Analyser("fft", 256); fft.smoothing = 0.85;
            limiter = new Tone.Limiter(-1).connect(fft); fft.toDestination(); 
            compressor = new Tone.Compressor({ threshold: -20, ratio: 4, attack: 0.01, release: 0.1 });
            chorus = new Tone.Chorus(4, 2.5, 0.5);
            reverb = new Tone.Reverb({ decay: 5, wet: 0.5 }); 
            pingPong = new Tone.PingPongDelay("4n", 0.2); 
            globalFilter = new Tone.Filter(4000, "lowpass", -12);
            panner = new Tone.Panner(0);
            eqLow = new Tone.Filter({ type: "lowshelf", frequency: localEQ.low.freq, gain: localEQ.low.gain, rolloff: -12 });
            eqMid = new Tone.Filter({ type: "peaking", frequency: localEQ.mid.freq, gain: localEQ.mid.gain, Q: 2.5 });
            eqHigh = new Tone.Filter({ type: "highshelf", frequency: localEQ.high.freq, gain: localEQ.high.gain, rolloff: -12 });
            
            compressor.connect(limiter);
            reverb.connect(compressor);
            chorus.connect(reverb);
            pingPong.connect(chorus);
            globalFilter.connect(pingPong); 
            eqHigh.connect(globalFilter); 
            eqMid.connect(eqHigh); 
            eqLow.connect(eqMid);
            panner.connect(eqLow);

            synth = new Tone.PolySynth(Tone.Synth, {
                maxPolyphony: 32, 
                volume: -10,
                oscillator: { 
                    type: "fattriangle", 
                    count: 3, 
                    spread: 30 
                }, 
                envelope: localADSR
            }).connect(panner); 

            updateSynthWave(waveBuffer);
            isStarted = true;
            document.getElementById('overlay').style.display = 'none';
            updateLayout();
        }
        document.getElementById('overlay').addEventListener('click', initAudio);

        // --- UI Element References ---
        const slA=document.getElementById('adsr-a'), slD=document.getElementById('adsr-d'), slS=document.getElementById('adsr-s'), slR=document.getElementById('adsr-r');
        const volSynth=document.getElementById('vol-synth');
        const autoNoteBtn = document.getElementById('auto-note-btn');
        const autoDriftBtn = document.getElementById('auto-drift-btn');
        const autoSpeed = document.getElementById('auto-speed');
        const scaleBtns = document.querySelectorAll('.scale-btn');
        const sensorBtn = document.getElementById('sensor-btn');
        const modeBtn = document.getElementById('mode-btn'); 
        const fillX = document.getElementById('fill-x'), fillY = document.getElementById('fill-y');
        const targetXBtn = document.getElementById('target-x-btn'), targetYBtn = document.getElementById('target-y-btn');
        const waveCanvas=document.getElementById('wave-canvas'), waveCtx=waveCanvas.getContext('2d'), resetBtn=document.getElementById('reset-btn');
        const adsrC=document.getElementById('adsr-canvas'), adsrCtx=adsrC.getContext('2d');

        const slFilt = document.getElementById('fx-filter');
        const slRev = document.getElementById('fx-reverb');
        const slDMix = document.getElementById('fx-delay-mix');
        const slDFb = document.getElementById('fx-delay-fb');
        const slPan = document.getElementById('fx-pan');
        
        const slVoices = document.getElementById('uni-voices');
        const slSpread = document.getElementById('uni-spread');
        
        const slGravY = document.getElementById('phys-grav-y');
        const slGravX = document.getElementById('phys-grav-x');
        const slLife = document.getElementById('phys-life');

        function updateValDisplay(id, val, suffix='') {
            const el = document.getElementById('disp-' + id);
            if(el) el.textContent = val + suffix;
        }

        // --- Sensor & Value Logic ---
        let isSensorActive = false; let lastSensorSync = 0;
        const ASSIGNABLE_PARAMS = ['FILTER', 'PAN', 'VOL', 'REVERB', 'DELAY_FB', 'DELAY_MIX', 'DECAY', 'RELEASE', 'FREQ'];
        let myTargets = { x: 'FILTER', y: 'REVERB' };
        
        function updateAllSystems(target, val, skipUI = false) {
            if (target === myTargets.x) cursorTargetPos.x = (val - 0.5) * playAreaSize;
            if (target === myTargets.y) cursorTargetPos.y = (val - 0.5) * playAreaSize;
            if (myTargets.x === target) meterTargetVal.x = val;
            if (myTargets.y === target) meterTargetVal.y = val;

            if (!synth) return;

            if (target === 'FILTER') { 
                const freq = 100 * Math.pow(80, val); 
                if(globalFilter) globalFilter.frequency.rampTo(freq, 0.1); 
                if(!skipUI && slFilt) slFilt.value = val;
                updateValDisplay('fx-filter', Math.round(val * 100), '%');
            } 
            else if (target === 'PAN') { 
                const panVal = (val * 2) - 1; 
                if(panner) panner.pan.rampTo(panVal, 0.1); 
                if(!skipUI && slPan) slPan.value = val;
                const txt = panVal === 0 ? "C" : (panVal < 0 ? "L"+Math.abs(Math.round(panVal*50)) : "R"+Math.round(panVal*50));
                updateValDisplay('fx-pan', txt);
            } 
            else if (target === 'VOL') { 
                const vol = (val * 60) - 60; 
                synth.volume.rampTo(vol, 0.1); 
                if(!skipUI) volSynth.value = vol; 
                updateValDisplay('vol-synth', Math.round(vol), 'dB');
            } 
            else if (target === 'REVERB') { 
                if(reverb) reverb.wet.rampTo(val, 0.1); 
                if(!skipUI && slRev) slRev.value = val;
                updateValDisplay('fx-reverb', Math.round(val * 100), '%');
            } 
            else if (target === 'DELAY_FB') { 
                if(pingPong) pingPong.feedback.rampTo(val * 0.9, 0.1); 
                if(!skipUI && slDFb) slDFb.value = val;
                updateValDisplay('fx-delay-fb', Math.round(val * 100), '%');
            }
            else if (target === 'DELAY_MIX') { 
                if(pingPong) pingPong.wet.rampTo(val, 0.1); 
                if(!skipUI && slDMix) slDMix.value = val;
                updateValDisplay('fx-delay-mix', Math.round(val * 100), '%');
            }
            else if (target === 'DECAY') { 
                const d = 0.1 + (val * 1.9); synth.set({ envelope: { decay: d } }); 
                if(!skipUI) { slD.value = d; drawADSRVisual(); }
                updateValDisplay('adsr-d', d.toFixed(2), 's');
            } 
            else if (target === 'RELEASE') { 
                const r = 0.1 + (val * 4.9); synth.set({ envelope: { release: r } }); 
                if(!skipUI) { slR.value = r; drawADSRVisual(); }
                updateValDisplay('adsr-r', r.toFixed(2), 's');
            }
            else if (target === 'FREQ') {
                const speed = Math.floor(val * 100);
                localAutoNote.speed = speed;
                if(!skipUI) autoSpeed.value = speed;
                updateValDisplay('auto-speed', speed, '%');
            }
            else if (target === 'UNISON_VOICES') {
                let voices = val;
                if (val <= 1.0 && !Number.isInteger(val)) voices = Math.floor(val * 4) + 1; 
                synth.set({ oscillator: { count: voices } });
                if(!skipUI && slVoices) slVoices.value = voices;
                updateValDisplay('uni-voices', voices);
            }
            else if (target === 'UNISON_SPREAD') {
                let spread = val;
                if (val <= 1.0) spread = val * 100;
                synth.set({ oscillator: { spread: spread } });
                if(!skipUI && slSpread) slSpread.value = spread;
                updateValDisplay('uni-spread', Math.round(spread));
            }
            else if (target === 'GRAVITY_Y') {
                localPhysics.y = val;
                if(!skipUI && slGravY) slGravY.value = val;
                const txt = val < 0.005 ? "Low" : (val > 0.015 ? "High" : "Mid");
                updateValDisplay('phys-grav-y', txt);
            }
            else if (target === 'GRAVITY_X') {
                localPhysics.x = val;
                if(!skipUI && slGravX) slGravX.value = val;
                const offset = Math.round((val - 0.5) * 100);
                updateValDisplay('phys-grav-x', offset);
            }
            else if (target === 'PHYSICS_LIFESPAN') {
                const ms = 100 + (val * 9900);
                localPhysics.lifespanMs = ms;
                if(!skipUI && slLife) slLife.value = val;
                updateValDisplay('phys-life', (ms/1000).toFixed(1), 's');
            }
        }

        function handleSensor(e) {
            if (!isStarted || !isSensorActive) return;

            const beta = e.beta || 0;   // 前後の傾き
            const gamma = e.gamma || 0; // 左右の傾き
            const now = Date.now();

            if (physicsMode) {
                // --- PHYSICSモード (そのまま) ---
                const clampGamma = Math.max(-45, Math.min(45, gamma));
                const targetGravX = 0.5 + (clampGamma / 45) * 0.5;

                const clampBeta = Math.max(-90, Math.min(90, beta));
                const maxGravity = 0.02;
                const targetGravY = (clampBeta / 90) * maxGravity; // プラス（スマホ立てると下に落ちる）

                updateAllSystems('GRAVITY_X', targetGravX);
                updateAllSystems('GRAVITY_Y', targetGravY);

                if (now - lastSensorSync > 50) {
                    socket.emit('update_param', { target: 'GRAVITY_X', value: targetGravX });
                    socket.emit('update_param', { target: 'GRAVITY_Y', value: targetGravY });
                    lastSensorSync = now;
                }

            } else {
                // --- TOUCHモード (ここを修正) ---
                
                // X (左右): 「1.0 -」を消して、標準に戻します（右に傾けると増える）
                const normX = (Math.max(-45, Math.min(45, gamma)) + 45) / 90;

                // Y (前後): 「1.0 -」を残して、反転のままにします
                // (これで手前に起こすと増えるか、奥に倒すと増えるか、好みの向きになります)
                const normY = 1.0 - ((Math.max(-45, Math.min(45, beta)) + 45) / 90);

                updateAllSystems(myTargets.x, normX); 
                updateAllSystems(myTargets.y, normY);
                
                if (now - lastSensorSync > 100) {
                    socket.emit('update_param', { target: myTargets.x, value: normX });
                    socket.emit('update_param', { target: myTargets.y, value: normY });
                    lastSensorSync = now;
                }
            }
        }

        targetXBtn.addEventListener('click', (e) => { e.stopPropagation();
            const idx = ASSIGNABLE_PARAMS.indexOf(myTargets.x); 
            myTargets.x = ASSIGNABLE_PARAMS[(idx + 1) % ASSIGNABLE_PARAMS.length];
            targetXBtn.textContent = myTargets.x.substring(0,4);
        });
        targetYBtn.addEventListener('click', (e) => { e.stopPropagation();
            const idx = ASSIGNABLE_PARAMS.indexOf(myTargets.y); 
            myTargets.y = ASSIGNABLE_PARAMS[(idx + 1) % ASSIGNABLE_PARAMS.length];
            targetYBtn.textContent = myTargets.y.substring(0,4);
        });

        modeBtn.addEventListener('click', (e) => {
            e.stopPropagation(); physicsMode = !physicsMode;
            if(physicsMode) { modeBtn.textContent = "MODE: GRAVITY"; modeBtn.classList.add('physics'); } 
            else { modeBtn.textContent = "MODE: TOUCH"; modeBtn.classList.remove('physics'); }
        });
        sensorBtn.addEventListener('click', async (e) => { e.stopPropagation();
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                try { const permission = await DeviceOrientationEvent.requestPermission(); if (permission === 'granted') toggleSensor(); else alert("Permission denied"); } catch (err) { console.error(err); }
            } else { toggleSensor(); }
        });
        function toggleSensor() {
            isSensorActive = !isSensorActive;
            if (isSensorActive) { sensorBtn.textContent = "SENSOR: ON"; sensorBtn.classList.add("active"); window.addEventListener('deviceorientation', handleSensor); } 
            else { sensorBtn.textContent = "SENSOR: OFF"; sensorBtn.classList.remove("active"); window.removeEventListener('deviceorientation', handleSensor); }
        }

        // --- Socket Receivers ---
        socket.on('sync_all_params', (params) => {
            for (const [key, val] of Object.entries(params)) { updateAllSystems(key, val); }
        });
        socket.on('sync_param', (data) => { 
            updateAllSystems(data.target, data.value);
            if(data.isGhost) triggerGlitch(data.target); 
        });
        socket.on('sync_waveform', d => { 
            waveBuffer = d; drawWave(waveBuffer); if(synth) updateSynthWave(d);
            if(isStarted) triggerGlitch('WAVE');
        });
        socket.on('sync_adsr', d => { 
            localADSR = d; 
            const normD = (d.decay - 0.1) / 1.9; const normR = (d.release - 0.1) / 4.9;
            updateAllSystems('DECAY', normD, true); updateAllSystems('RELEASE', normR, true);
            
            slA.value=d.attack; slS.value=d.sustain; 
            updateValDisplay('adsr-a', d.attack.toFixed(2), 's');
            updateValDisplay('adsr-s', Math.round(d.sustain*100), '%');
            drawADSRVisual();
            if(synth) synth.set({ envelope: localADSR }); 
            if(synth) synth.set({envelope:d});
        });
        socket.on('sync_mixer', d => {
            localMixer = d; const normVol = (d.synth + 60) / 60;
            updateAllSystems('VOL', Math.max(0, Math.min(1, normVol)));
        });
        socket.on('sync_eq', d => { 
            localEQ = d; 
            if(eqLow){ eqLow.frequency.value=d.low.freq; eqLow.gain.value=d.low.gain; eqMid.frequency.value=d.mid.freq; eqMid.gain.value=d.mid.gain; eqHigh.frequency.value=d.high.freq; eqHigh.gain.value=d.high.gain; } 
        });
        socket.on('sync_scale', (scaleName) => { 
            currentScaleName = scaleName; scaleDisplay.textContent = "SCALE: " + currentScaleName;
            scaleBtns.forEach(btn => { if(btn.dataset.scale === scaleName) btn.classList.add('active'); else btn.classList.remove('active'); }); 
        });
        socket.on('sync_auto_note', (data) => {
            localAutoNote = data;
            if(localAutoNote.active) { autoNoteBtn.textContent = "NOTES: ON"; autoNoteBtn.classList.add("active"); } 
            else { autoNoteBtn.textContent = "NOTES: OFF"; autoNoteBtn.classList.remove("active"); }
            autoSpeed.value = localAutoNote.speed;
            updateValDisplay('auto-speed', localAutoNote.speed, '%');
        });
        socket.on('sync_auto_drift', (data) => {
            localAutoDrift = data;
            if(localAutoDrift.active) { autoDriftBtn.textContent = "GHOST: ON"; autoDriftBtn.classList.add("ghost-active"); } 
            else { autoDriftBtn.textContent = "GHOST: OFF"; autoDriftBtn.classList.remove("ghost-active"); }
        });
        socket.on('spawn_ball', (data) => { if (data.id !== socket.id) spawnBallVisual(data.x, data.y, data.id, false); });


        // --- UI Events (Emit) ---
        const emitParam = (target, val) => {
            updateAllSystems(target, val, true); 
            socket.emit('update_param', { target: target, value: val });
        };
        slFilt.addEventListener('input', () => emitParam('FILTER', parseFloat(slFilt.value)));
        slRev.addEventListener('input', () => emitParam('REVERB', parseFloat(slRev.value)));
        slDMix.addEventListener('input', () => emitParam('DELAY_MIX', parseFloat(slDMix.value)));
        slDFb.addEventListener('input', () => emitParam('DELAY_FB', parseFloat(slDFb.value)));
        slPan.addEventListener('input', () => emitParam('PAN', parseFloat(slPan.value)));
        
        slVoices.addEventListener('input', () => emitParam('UNISON_VOICES', parseInt(slVoices.value)));
        slSpread.addEventListener('input', () => emitParam('UNISON_SPREAD', parseFloat(slSpread.value)));
        
        slGravY.addEventListener('input', () => emitParam('GRAVITY_Y', parseFloat(slGravY.value)));
        slGravX.addEventListener('input', () => emitParam('GRAVITY_X', parseFloat(slGravX.value)));
        slLife.addEventListener('input', () => emitParam('PHYSICS_LIFESPAN', parseFloat(slLife.value)));

        let lastAutoSync = 0;
        autoNoteBtn.addEventListener('click', (e) => { e.stopPropagation(); localAutoNote.active = !localAutoNote.active; socket.emit('update_auto_note', localAutoNote); });
        autoDriftBtn.addEventListener('click', (e) => { e.stopPropagation(); localAutoDrift.active = !localAutoDrift.active; socket.emit('update_auto_drift', localAutoDrift); });
        autoSpeed.addEventListener('input', () => { 
            localAutoNote.speed = parseInt(autoSpeed.value); 
            updateValDisplay('auto-speed', localAutoNote.speed, '%');
            if(Date.now() - lastAutoSync > 100) { socket.emit('update_auto_note', localAutoNote); lastAutoSync = Date.now(); } 
        });
        let lastMixerSync = 0;
        volSynth.addEventListener('input',()=>{ 
            const val = parseFloat(volSynth.value); const normVol = (val + 60) / 60;
            updateAllSystems('VOL', normVol, true); localMixer.synth = val;
            if(Date.now()-lastMixerSync>30){socket.emit('update_mixer',localMixer);lastMixerSync=Date.now();} 
        });
        
        let lastAdsrSync = 0;
        const updateADSR=()=>{ 
            localADSR={attack:parseFloat(slA.value),decay:parseFloat(slD.value),sustain:parseFloat(slS.value),release:parseFloat(slR.value)};
            const normD = (localADSR.decay - 0.1) / 1.9; const normR = (localADSR.release - 0.1) / 4.9;
            updateAllSystems('DECAY', normD, true); updateAllSystems('RELEASE', normR, true);
            
            updateValDisplay('adsr-a', localADSR.attack.toFixed(2), 's');
            updateValDisplay('adsr-s', Math.round(localADSR.sustain*100), '%');
            
            drawADSRVisual();
            if(synth) synth.set({ envelope: localADSR });

            if(Date.now() - lastAdsrSync > 30) { socket.emit('update_adsr',localADSR); lastAdsrSync = Date.now(); }
        };
        [slA,slD,slS,slR].forEach(s=>{ s.addEventListener('input',updateADSR); });

        scaleBtns.forEach(btn => {
            btn.addEventListener('pointerdown', (e) => { e.stopPropagation(); scaleBtns.forEach(b => b.classList.remove('active')); btn.classList.add('active'); scaleDisplay.textContent = "SCALE: " + btn.dataset.scale + " (SYNCING...)"; socket.emit('update_scale', btn.dataset.scale); });
        });

        let lastWaveSync = 0; let isDrawingWave=false;
        function drawWave(b){ 
            const w=waveCanvas.width, h=waveCanvas.height, c=h/2;
            waveCtx.clearRect(0,0,w,h); 
            waveCtx.strokeStyle = isPC ? '#666' : '#333'; 
            waveCtx.beginPath(); waveCtx.moveTo(0,c); waveCtx.lineTo(w,c); waveCtx.stroke(); 
            waveCtx.beginPath(); 
            waveCtx.strokeStyle = isPC ? '#ffffff' : '#ccc'; 
            waveCtx.lineWidth=1; 
            for(let i=0;i<WAVE_SIZE;i++){ const x=(i/(WAVE_SIZE-1))*w, y=c-(b[i]*(h/2)); if(i===0)waveCtx.moveTo(x,y); else waveCtx.lineTo(x,y); } 
            waveCtx.stroke(); 
        }
        function updateWave(cx,cy){ 
            const r=waveCanvas.getBoundingClientRect(); const nx=Math.max(0,Math.min(1,(cx-r.left)/r.width)), ny=-((Math.max(0,Math.min(1,(cy-r.top)/r.height))*2)-1);
            const idx=Math.floor(nx*(WAVE_SIZE-1)); if(idx>=0&&idx<WAVE_SIZE) waveBuffer[idx]=ny; 
            drawWave(waveBuffer); updateSynthWave(waveBuffer);
            if(Date.now() - lastWaveSync > 30) { socket.emit('update_waveform', waveBuffer); lastWaveSync = Date.now(); }
        }
        function updateSynthWave(buffer) {
            if(!synth) return;
            const N = buffer.length; const numHarmonics = 32; const partials = [];
            for (let k = 1; k <= numHarmonics; k++) {
                let r = 0, i = 0;
                for (let n = 0; n < N; n++) { const angle = (2 * Math.PI * k * n) / N; r += buffer[n] * Math.cos(angle); i += buffer[n] * Math.sin(angle); }
                partials.push(Math.sqrt(r * r + i * i));
            }
            const max = Math.max(...partials); synth.set({oscillator:{partials:max>0.0001?partials.map(v=>v/max):partials}});
        }
        const handleWaveStart = e => { isDrawingWave = true; if(e.type === 'mousedown') handleWaveMove(e); else if(e.type === 'touchstart') { e.preventDefault(); updateWave(e.touches[0].clientX, e.touches[0].clientY); } }; 
        const handleWaveEnd = () => { if(isDrawingWave){isDrawingWave=false; socket.emit('update_waveform',waveBuffer)} }; 
        const handleWaveMove = e => { if(!isDrawingWave) return; e.preventDefault(); const t = e.touches ? e.touches[0] : e; updateWave(t.clientX, t.clientY); };
        waveCanvas.addEventListener('mousedown', handleWaveStart); window.addEventListener('mouseup', handleWaveEnd); waveCanvas.addEventListener('mousemove', handleWaveMove);
        waveCanvas.addEventListener('touchstart', handleWaveStart, {passive: false}); window.addEventListener('touchend', handleWaveEnd); waveCanvas.addEventListener('touchmove', handleWaveMove, {passive: false});
        resetBtn.addEventListener('click', e=>{e.stopPropagation(); waveBuffer=waveBuffer.map((_,i)=>Math.sin((i/WAVE_SIZE)*Math.PI*2)); drawWave(waveBuffer); updateSynthWave(waveBuffer); socket.emit('update_waveform',waveBuffer)});

        function drawADSRVisual(){ 
            const w=adsrC.width, h=adsrC.height; adsrCtx.clearRect(0,0,w,h); 
            const A=parseFloat(slA.value), D=parseFloat(slD.value), S=parseFloat(slS.value), R=parseFloat(slR.value);
            adsrCtx.beginPath(); 
            adsrCtx.strokeStyle = isPC ? '#aaa' : '#666'; 
            adsrCtx.lineWidth=1;
            const x1=(A/2)*(w*0.25), y2=h-(S*h), x2=x1+(D/2)*(w*0.25), x3=x2+(w*0.2), x4=Math.min(w,x3+(R/5)*(w*0.3));
            adsrCtx.moveTo(0,h); adsrCtx.lineTo(x1,0); adsrCtx.lineTo(x2,y2); adsrCtx.lineTo(x3,y2); adsrCtx.lineTo(x4,h); adsrCtx.stroke();
        }

        const eqCanvas = document.getElementById('eq-canvas'); const eqCtx = eqCanvas.getContext('2d'); const eqReadout = document.getElementById('eq-readout');
        const minFreq = 20; const maxFreq = 20000;
        function xToFreq(x, width) { return minFreq * Math.pow(maxFreq / minFreq, x / width); }
        function freqToX(freq, width) { return (Math.log(freq / minFreq) / Math.log(maxFreq / minFreq)) * width; }
        function yToDb(y, height) { return 12 - (y / height) * 24; }
        function dbToY(db, height) { return height/2 - (db/24) * height; }
        function getEQResponse(f) {
            let db = 0;
            if (localEQ.low.gain !== 0) db += localEQ.low.gain * (1 / (1 + Math.pow(f / localEQ.low.freq, 4)));
            if (localEQ.high.gain !== 0) db += localEQ.high.gain * (1 / (1 + Math.pow(localEQ.high.freq / f, 4)));
            if (localEQ.mid.gain !== 0) { const Q=2.5; db += localEQ.mid.gain * Math.exp( -Math.pow( (Math.log(f/localEQ.mid.freq)) * Q, 2 ) ); }
            return db;
        }
        let draggingPoint = null; let lastEqSyncTime = 0;
        function drawEQ() {
            const w = eqCanvas.width; const h = eqCanvas.height; eqCtx.clearRect(0, 0, w, h);
            if (fft) {
                const values = fft.getValue(); const nyquist = Tone.context.sampleRate / 2; const fftSize = values.length;
                eqCtx.fillStyle = '#1a1a1a'; eqCtx.beginPath(); eqCtx.moveTo(0, h);
                for (let i = 0; i < fftSize; i++) {
                    const db = values[i]; if (db === -Infinity) continue;
                    const freq = i * (nyquist / fftSize); const x = freqToX(freq, w); if (x < 0) continue; if (x > w) break; 
                    const barHeight = Math.max(0, (db + 100) / 100 * h); eqCtx.lineTo(x, h - barHeight);
                }
                eqCtx.lineTo(w, h); eqCtx.fill();
            }
            eqCtx.strokeStyle = '#333'; eqCtx.lineWidth = 1; eqCtx.beginPath();
            [100, 1000, 10000].forEach(f => { const x = freqToX(f, w); eqCtx.moveTo(x, 0); eqCtx.lineTo(x, h); });
            eqCtx.moveTo(0, h/2); eqCtx.lineTo(w, h/2); eqCtx.stroke();
            eqCtx.strokeStyle = isPC ? '#fff' : '#ccc'; eqCtx.lineWidth = 1.5; eqCtx.beginPath();
            for (let x = 0; x < w; x+=2) { const y = dbToY(getEQResponse(xToFreq(x, w)), h); if (x === 0) eqCtx.moveTo(x, y); else eqCtx.lineTo(x, y); }
            eqCtx.stroke(); 
            [ {id:'low'}, {id:'mid'}, {id:'high'} ].forEach(p => {
                const d = localEQ[p.id]; const x = freqToX(d.freq, w); const y = dbToY(d.gain, h);
                eqCtx.fillStyle = '#000'; eqCtx.strokeStyle = isPC ? '#fff' : '#aaa'; eqCtx.lineWidth = 1; 
                eqCtx.beginPath(); eqCtx.arc(x, y, 4, 0, Math.PI*2); eqCtx.fill(); eqCtx.stroke();
                if(draggingPoint===p.id){ eqCtx.fillStyle='#fff'; eqCtx.fill(); }
            });
        }
        function handleEQMove(cx, cy, isDown) {
            const r = eqCanvas.getBoundingClientRect(); const x = Math.max(0, Math.min(r.width, cx - r.left)); const y = Math.max(0, Math.min(r.height, cy - r.top));
            if (isDown) {
                const pts = ['low','mid','high'].map(k => ({id:k, x:freqToX(localEQ[k].freq, r.width), y:dbToY(localEQ[k].gain, r.height)}));
                for(let p of pts) if(Math.hypot(p.x-x, p.y-y)<30) draggingPoint=p.id;
            }
            if (draggingPoint) {
                const f = xToFreq(x, r.width); const g = Math.max(-12, Math.min(12, yToDb(y, r.height)));
                localEQ[draggingPoint].freq=f; localEQ[draggingPoint].gain=g;
                if(eqLow){ 
                    if(draggingPoint==='low'){ eqLow.frequency.value=f; eqLow.gain.value=g; }
                    if(draggingPoint==='mid'){ eqMid.frequency.value=f; eqMid.gain.value=g; }
                    if(draggingPoint==='high'){ eqHigh.frequency.value=f; eqHigh.gain.value=g; }
                }
                eqReadout.textContent=`${draggingPoint.toUpperCase()}`; 
                if (Date.now() - lastEqSyncTime > 30) { socket.emit('update_eq', localEQ); lastEqSyncTime = Date.now(); }
            }
        }
        const endEQDrag = () => { if(draggingPoint){ socket.emit('update_eq', localEQ); draggingPoint=null; eqReadout.textContent="DRAG"; }};
        eqCanvas.addEventListener('mousedown', e=>handleEQMove(e.clientX,e.clientY,true)); window.addEventListener('mousemove', e=>{if(draggingPoint)handleEQMove(e.clientX,e.clientY,false)}); window.addEventListener('mouseup', endEQDrag);
        eqCanvas.addEventListener('touchstart', e=>{e.preventDefault(); handleEQMove(e.touches[0].clientX,e.touches[0].clientY,true)},{passive:false}); window.addEventListener('touchmove', e=>{if(draggingPoint){e.preventDefault(); handleEQMove(e.touches[0].clientX,e.touches[0].clientY,false)}},{passive:false}); window.addEventListener('touchend', endEQDrag);

        let lastMoveNoteTime = 0; const MOVE_NOTE_INTERVAL = 100;
        function triggerNoteFromPhysics(normX, volumeGain) {
            const scaleNotes = SCALES[currentScaleName] || SCALES["MYSTERIOUS"];
            const clampX = Math.max(0, Math.min(1, normX));
            const noteIndex = Math.floor((1 - clampX) * scaleNotes.length);
            const note = scaleNotes[Math.min(noteIndex, scaleNotes.length - 1)];
            if (!synth) return;
            
            const velocity = Math.min(1.0, 0.1 + (volumeGain || 0));
            synth.triggerAttackRelease(note, "8n", Tone.now(), velocity);
            
            const xPos = (clampX - 0.5) * playAreaSize; const yPos = -(playAreaSize / 2) + playAreaOffsetY;
            const mesh = new THREE.Mesh(new THREE.RingGeometry(0.98, 1.0, 32), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, side: THREE.DoubleSide }));
            mesh.position.set(xPos, yPos, 0); mesh.rotation.x = Math.PI / 2;
            scene.add(mesh);
            visualObjects.push({ type: 'ring', mesh, startTime: Date.now(), duration: 0.8 });
        }
        function triggerNoteFromInput(normX, normY) {
            if (normX < 0 || normX > 1 || normY < 0 || normY > 1) return;
            const scaleNotes = SCALES[currentScaleName] || SCALES["MYSTERIOUS"];
            const noteIndex = Math.floor((1 - normY) * scaleNotes.length);
            const note = scaleNotes[Math.min(noteIndex, scaleNotes.length - 1)];
            const noteData = { note, duration: 0.5 + normX * 4.0, normX, normY, id: socket.id };
            playAndVisualizeNote(noteData); 
            socket.emit('play_note', { note, duration: noteData.duration, normX, normY });
        }
        function spawnBallVisual(x, y, id, isLocal) {
            const color = isLocal ? 0xffffff : 0x888888;
            const ballGeo = new THREE.SphereGeometry(playAreaSize * 0.02, 16, 16);
            const ballMat = new THREE.MeshBasicMaterial({ color: color, wireframe: true });
            const ballMesh = new THREE.Mesh(ballGeo, ballMat);
            const wX = (x - 0.5) * playAreaSize; 
            const wY = (y - 0.5) * playAreaSize + playAreaOffsetY;
            ballMesh.position.set(wX, wY, 0); scene.add(ballMesh);
            
            if (y <= 0.01) {
                triggerNoteFromPhysics(x, 0.5); 
            }
            balls.push({ mesh: ballMesh, vy: 0, vx: 0, x: x, y: y, id: id, spawnTime: Date.now(), lastHit: 0 });
        }
        let currentPointerPos = null;
        function handleInput(e, isMove) {
            if (!isStarted) return;
            const target = e.target;
            if (['INPUT', 'BUTTON'].includes(target.tagName)) return;
            if (['wave-canvas','adsr-canvas','eq-canvas'].includes(target.id)) return;
            if (target.closest('.scale-grid')) return;
            const cX = e.touches ? e.touches[0].clientX : e.clientX;
            const cY = e.touches ? e.touches[0].clientY : e.clientY;
            currentPointerPos = { x: cX, y: cY };
            const controlsRect = document.getElementById('controls').getBoundingClientRect();
            if (controlsRect.top <= cY) return;
            const w = window.innerWidth; const h = window.innerHeight;
            const centerX = w / 2; const centerY = (h / 2) - playAreaOffsetY;
            const normX = ((cX - centerX) / playAreaSize) + 0.5; const normY = ((cY - centerY) / playAreaSize) + 0.5;
            
            const physY = 1.0 - normY;

            if (physicsMode) {
                if (!isMove && normX >= 0 && normX <= 1 && physY >= 0 && physY <= 1) { 
                    spawnBallVisual(normX, physY, socket.id, true); 
                    socket.emit('spawn_ball', { x: normX, y: physY }); 
                }
            } else {
                if (isMove) { const now = Date.now(); if (now - lastMoveNoteTime > MOVE_NOTE_INTERVAL) { triggerNoteFromInput(normX, normY); lastMoveNoteTime = now; } } 
                else { triggerNoteFromInput(normX, normY); lastMoveNoteTime = Date.now(); }
            }
        }
        let isPointerDown = false;
        const onPointerDown = e => { isPointerDown = true; handleInput(e, false); };
        const onPointerMove = e => { 
            if (isPointerDown) { const target = e.target; if (!document.getElementById('controls').contains(target)) { e.preventDefault(); handleInput(e, true); } } else { currentPointerPos = null; }
        };
        const onPointerUp = () => { isPointerDown = false; prevNotePos = null; currentPointerPos = null; };
        window.addEventListener('mousedown', onPointerDown); window.addEventListener('mousemove', onPointerMove); window.addEventListener('mouseup', onPointerUp);
        window.addEventListener('touchstart', onPointerDown, {passive: false}); window.addEventListener('touchmove', onPointerMove, {passive: false}); window.addEventListener('touchend', onPointerUp);

        function playAndVisualizeNote(data) {
            if (!synth) return;
            synth.triggerAttackRelease(data.note, data.duration);
            const xPos = (data.normX - 0.5) * playAreaSize; const yPos = -(data.normY - 0.5) * playAreaSize + playAreaOffsetY;
            const pos = new THREE.Vector3(xPos, yPos, 0);
            const isAuto = data.id === 'auto';
            const color = 0xffffff; 
            const opacity = isAuto ? 0.3 : 0.8;
            
            const innerR = isPC ? 0.95 : 0.99; 
            const mesh = new THREE.Mesh(new THREE.RingGeometry(innerR, 1.0, 64), new THREE.MeshBasicMaterial({ color: color, transparent: true, side: THREE.DoubleSide, opacity: opacity }));
            mesh.position.copy(pos); scene.add(mesh);
            visualObjects.push({ type: 'ring', mesh, startTime: Date.now(), duration: data.duration });
            if (prevNotePos && !isAuto) { 
                const points = [prevNotePos.clone(), pos.clone()];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.15 });
                const line = new THREE.Line(geometry, material); scene.add(line);
                visualObjects.push({ type: 'line', mesh: line, startTime: Date.now(), duration: data.duration * 2.0 }); 
            }
            if(!isAuto && data.id === socket.id) prevNotePos = pos;
        }
        socket.on('trigger_note', (data) => { if (data.id !== socket.id) playAndVisualizeNote(data); });
    </script>
</body>
</html>
