<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Synth Master Sync</title>
    <style>
        body { margin: 0; overflow: hidden; background: #080808; touch-action: none; color: white; font-family: monospace; }
        
        /* 起動ボタン (重要: これがないとスマホで音が出ない) */
        #start-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 9999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            cursor: pointer;
        }
        #start-btn {
            background: transparent; border: 2px solid #00ffcc; color: #00ffcc;
            padding: 20px 50px; font-size: 20px; letter-spacing: 4px;
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.4);
            animation: pulse 2s infinite; cursor: pointer;
        }
        @keyframes pulse { 0% { opacity: 0.8; } 50% { opacity: 1; box-shadow: 0 0 40px rgba(0, 255, 204, 0.8); } 100% { opacity: 0.8; } }

        /* バージョン表記 */
        #version {
            position: fixed; bottom: 5px; right: 10px; font-size: 10px; color: #444; z-index: 200; pointer-events: none;
        }

        /* メインキャンバス (背景) */
        #main-canvas {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1; 
        }

        /* コントロールパネル */
        #controls {
            position: fixed; bottom: 0; left: 0; width: 100%; height: 280px; 
            background: linear-gradient(transparent, rgba(0,0,0,0.95) 15%);
            display: flex; flex-direction: row; justify-content: center; align-items: center;
            padding-bottom: 20px; z-index: 100; gap: 15px; box-sizing: border-box;
            overflow-x: auto; touch-action: pan-x;
        }
        #controls::-webkit-scrollbar { display: none; } 

        .panel-section {
            display: flex; flex-direction: column; align-items: center;
            background: rgba(10, 10, 10, 0.85); border: 1px solid #333; border-radius: 6px;
            padding: 10px; backdrop-filter: blur(10px); width: 260px; height: 210px;
            justify-content: flex-start; box-shadow: 0 4px 15px rgba(0,0,0,0.6);
            flex-shrink: 0; position: relative; transition: border-color 0.1s, box-shadow 0.1s;
        }
        .label { font-size: 11px; color: #00ffcc; margin-bottom: 8px; letter-spacing: 2px; font-weight: bold; pointer-events: none; }

        /* 操作用キャンバス */
        .interactive-canvas {
            background: rgba(0, 0, 0, 0.5); border: 1px solid #444; border-radius: 4px;
            cursor: crosshair; touch-action: none;
        }
        
        .eq-values { font-size: 10px; color: #888; width: 100%; text-align: center; margin-top: 5px; }
        .mixer-container { display: flex; gap: 30px; height: 100%; align-items: center; justify-content: center; }
        #adsr-container { display: flex; flex-direction: column; align-items: center; width: 100%; }
        .sliders { display: flex; gap: 15px; width: 100%; justify-content: space-between; margin-top: 5px; }
        .slider-group { display: flex; flex-direction: column; align-items: center; }
        
        input[type=range].vertical {
            -webkit-appearance: none; appearance: none; width: 40px; height: 90px;
            background: transparent; writing-mode: bt-lr; -webkit-appearance: slider-vertical;
            cursor: pointer; touch-action: none;
        }
        input[type=range].vertical::-webkit-slider-thumb {
            -webkit-appearance: none; width: 30px; height: 15px; 
            background: #00ffcc; border-radius: 2px; box-shadow: 0 0 10px rgba(0,255,204,0.5);
            margin-left: -5px;
        }
        .param-label { font-size: 10px; color: #666; margin-top: 6px; font-weight: bold; }

        .btn-group { display: flex; gap: 10px; margin-top: 10px; }
        button.ctrl-btn {
            background: rgba(0,0,0,0.6); border: 1px solid #333; color: #00ffcc;
            font-size: 12px; padding: 10px 20px; cursor: pointer; border-radius: 4px;
            touch-action: manipulation;
        }
        button.ctrl-btn.active { background: #00ffcc; color: #000; font-weight: bold; }

        .scale-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; width: 100%; margin-top: 5px; height: 100%; overflow-y: auto; }
        .scale-btn { 
            padding: 10px 4px; font-size: 10px; text-align: left; 
            border: 1px solid #333; background: rgba(0,0,0,0.3); color: #aaa; cursor: pointer;
            touch-action: manipulation;
        }
        .scale-btn.active { border-color: #00ffcc; background: rgba(0,255,204,0.2); color: white; }

        #status-bar {
            position: fixed; top: 20px; left: 20px; z-index: 100;
            display: flex; gap: 10px; align-items: center; font-size: 10px; color: #888; pointer-events: none;
        }
        .my-color-dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-left: 5px; border: 1px solid #fff; }

        #sensor-btn {
            position: fixed; top: 20px; right: 20px; z-index: 200;
            background: rgba(0,0,0,0.8); border: 1px solid #444; color: #888;
            padding: 12px 16px; font-size: 11px; border-radius: 20px; cursor: pointer;
        }
        #sensor-btn.active { border-color: #00ffcc; color: #00ffcc; background: rgba(0,255,204,0.1); }

        #sensor-panel {
            position: fixed; top: 70px; right: 20px; z-index: 90; display: flex; gap: 12px;
        }
        .sensor-group { display: flex; flex-direction: column; align-items: center; gap: 5px; }
        .sensor-meter {
            width: 12px; height: 80px; background: rgba(255,255,255,0.1);
            border-radius: 4px; position: relative; overflow: hidden;
            display: flex; flex-direction: column-reverse; border: 1px solid #333;
        }
        .sensor-fill { width: 100%; height: 50%; background: #00ffcc; transition: height 0.1s; }
        .target-btn {
            font-size: 9px; color: #00ffcc; background: rgba(0,0,0,0.8);
            border: 1px solid #444; padding: 6px; width: 50px; text-align: center; cursor: pointer;
        }

        @media (min-width: 1100px) { #controls { justify-content: center; gap: 20px; } }
        @media (max-width: 1099px) { 
            #controls { justify-content: flex-start; overflow-x: auto; padding: 10px 20px 30px 20px; scroll-snap-type: x mandatory; } 
            #controls::-webkit-scrollbar { display: none; } 
            .panel-section { scroll-snap-align: center; margin-right: 5px; } 
        }
    </style>
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    
    <div id="start-overlay">
        <button id="start-btn">POWER ON</button>
        <div style="color:#666; font-size:10px; margin-top:10px;">TAP TO START AUDIO & SENSORS</div>
    </div>

    <div id="status-bar">
        <span id="user-count">OFFLINE</span>
        <span>YOU: <span id="my-color" class="my-color-dot"></span></span>
    </div>
    <div id="version">v2.0 (Sensor & Sync)</div>

    <button id="sensor-btn">SENSOR: OFF</button>
    
    <div id="sensor-panel">
        <div class="sensor-group">
            <div class="sensor-meter"><div class="sensor-fill" id="fill-x"></div></div>
            <button class="target-btn" id="target-x-btn">FILTER</button>
        </div>
        <div class="sensor-group">
            <div class="sensor-meter"><div class="sensor-fill" id="fill-y" style="background:#ff00cc; box-shadow: 0 0 10px #ff00cc;"></div></div>
            <button class="target-btn" id="target-y-btn">REVERB</button>
        </div>
    </div>

    <div id="controls">
        <div class="panel-section" id="panel-wave">
            <div class="label">1. WAVEFORM</div>
            <canvas id="wave-canvas" class="interactive-canvas" width="240" height="90"></canvas>
            <div class="btn-group">
                <button class="ctrl-btn" id="reset-btn">RESET</button>
                <button class="ctrl-btn" id="auto-btn">AUTO: OFF</button>
            </div>
        </div>

        <div class="panel-section" id="panel-eq">
            <div class="label">2. EQ & SPECTRUM</div>
            <div id="eq-container">
                <canvas id="eq-canvas" class="interactive-canvas" width="240" height="100"></canvas>
                <div class="eq-values" id="eq-readout">DRAG POINTS</div>
            </div>
        </div>

        <div class="panel-section" id="panel-mixer">
            <div class="label">3. MIXER & AUTO</div>
            <div class="mixer-container">
                <div class="slider-group"><input type="range" class="vertical" id="vol-synth" min="-60" max="0" step="1" value="-6"><span class="param-label">VOL</span></div>
                <div class="slider-group"><input type="range" class="vertical" id="auto-speed" min="0" max="100" step="1" value="30"><span class="param-label">FREQ</span></div>
            </div>
        </div>

        <div class="panel-section" id="panel-adsr">
            <div class="label">4. ENVELOPE</div>
            <div id="adsr-container">
                <canvas id="adsr-canvas" class="interactive-canvas" width="240" height="70"></canvas>
                <div class="sliders">
                    <div class="slider-group"><input type="range" class="vertical" id="adsr-a" min="0.01" max="2.0" step="0.01" value="0.05"><span class="param-label">A</span></div>
                    <div class="slider-group"><input type="range" class="vertical" id="adsr-d" min="0.1" max="2.0" step="0.01" value="0.2"><span class="param-label">D</span></div>
                    <div class="slider-group"><input type="range" class="vertical" id="adsr-s" min="0" max="1.0" step="0.01" value="0.5"><span class="param-label">S</span></div>
                    <div class="slider-group"><input type="range" class="vertical" id="adsr-r" min="0.1" max="5.0" step="0.1" value="1.0"><span class="param-label">R</span></div>
                </div>
            </div>
        </div>

        <div class="panel-section" id="panel-scale">
            <div class="label">5. SCALE (MOOD)</div>
            <div class="scale-grid">
                <button class="scale-btn active" data-scale="MINOR_PENTATONIC">MINOR PENTATONIC</button>
                <button class="scale-btn" data-scale="MAJOR">MAJOR</button>
                <button class="scale-btn" data-scale="MINOR">MINOR</button>
                <button class="scale-btn" data-scale="DORIAN">DORIAN</button>
                <button class="scale-btn" data-scale="LYDIAN">LYDIAN</button>
                <button class="scale-btn" data-scale="RYUKYU">RYUKYU</button>
                <button class="scale-btn" data-scale="MIYAKOBUSHI">MIYAKOBUSHI</button>
                <button class="scale-btn" data-scale="WHOLE_TONE">WHOLE TONE</button>
            </div>
        </div>
    </div>

    <script>
        const socket = io();
        let isAudioReady = false;
        let myId = null;
        let connectedUsers = {};
        
        let state = {
            waveform: new Array(128).fill(0),
            eq: { low: {freq:100, gain:0}, mid: {freq:1000, gain:0}, high: {freq:5000, gain:0} },
            mixer: { synth: -6 },
            adsr: { attack: 0.05, decay: 0.2, sustain: 0.5, release: 1.0 },
            params: { 'FILTER': 0.5, 'PAN': 0.5, 'VOL': 0.8, 'REVERB': 0.0, 'ATTACK':0.05, 'DECAY':0.2, 'SUSTAIN':0.5, 'RELEASE':0.3 },
            auto: { active: false, speed: 30 },
            scale: "MINOR_PENTATONIC"
        };

        let synth, limiter, chorus, reverb, fft, panner, globalFilter;
        let eqLow, eqMid, eqHigh;

        // Visuals
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 1, 1000);
        camera.position.z = 10;
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.domElement.id = 'main-canvas';
        document.body.appendChild(renderer.domElement);
        
        const visualObjects = [];
        let playAreaSize = 0;
        let playAreaOffsetY = 0;
        let prevNotePos = null;

        // --- Initialize ---
        document.getElementById('start-btn').addEventListener('click', async () => {
            if(isAudioReady) return;
            await Tone.start();
            initAudioEngine();
            document.getElementById('start-overlay').style.display = 'none';
            isAudioReady = true;
        });

        function initAudioEngine() {
            fft = new Tone.Analyser("fft", 256);
            fft.smoothing = 0.85;
            limiter = new Tone.Limiter(-1).connect(fft);
            fft.toDestination();

            chorus = new Tone.Chorus(4, 2.5, 0.5);
            reverb = new Tone.Reverb({ decay: 5, wet: state.params.REVERB });
            globalFilter = new Tone.Filter(20000, "lowpass", -12);
            panner = new Tone.Panner(0);

            eqLow = new Tone.Filter({ type: "lowshelf", frequency: state.eq.low.freq, gain: state.eq.low.gain });
            eqMid = new Tone.Filter({ type: "peaking", frequency: state.eq.mid.freq, gain: state.eq.mid.gain, Q: 2.5 });
            eqHigh = new Tone.Filter({ type: "highshelf", frequency: state.eq.high.freq, gain: state.eq.high.gain });

            // Chain: Synth -> Panner -> Filter -> EQ -> Chorus -> Reverb -> Limiter
            reverb.connect(limiter);
            chorus.connect(reverb);
            eqHigh.connect(chorus);
            eqMid.connect(eqHigh);
            eqLow.connect(eqMid);
            globalFilter.connect(eqLow);
            panner.connect(globalFilter);

            synth = new Tone.PolySynth(Tone.Synth, {
                maxPolyphony: 20,
                volume: state.mixer.synth,
                oscillator: { type: "triangle" },
                envelope: state.adsr
            }).connect(panner);

            updateSynthWave(state.waveform);
            updateLayout();
            resizeCanvases();
        }

        // --- Socket Events ---
        socket.on('init_state', (data) => {
            myId = data.id;
            document.getElementById('my-color').style.backgroundColor = data.color;
            if(data.state) {
                state = data.state;
                if(isAudioReady) reflectAllState();
                else {
                    updateADSRUI(); updateMixerUI(); updateScaleUI(); updateAutoUI(); resizeCanvases();
                }
            }
            if(data.users) connectedUsers = data.users;
        });

        socket.on('update_users', (users) => {
            connectedUsers = users;
            document.getElementById('user-count').textContent = `ONLINE: ${Object.keys(users).length}`;
        });

        socket.on('sync_state_part', (data) => {
            state[data.key] = data.value;
            if(data.key === 'waveform') { updateSynthWave(data.value); resizeCanvases(); }
            if(data.key === 'eq') { updateEQNodes(); resizeCanvases(); }
            if(data.key === 'adsr') { updateADSRNodes(); updateADSRUI(); resizeCanvases(); }
            if(data.key === 'mixer') { updateMixerNodes(); updateMixerUI(); }
            if(data.key === 'scale') { updateScaleUI(); }
            if(data.key === 'auto') { updateAutoUI(); }
            flashPanelByKey(data.key, data.userId);
        });

        socket.on('sync_param', (data) => {
            state.params[data.target] = data.value;
            applyParam(data.target, data.value);
            
            const user = connectedUsers[data.userId];
            const color = user ? user.color : '#fff';
            if(['FILTER','REVERB'].includes(data.target)) flashPanel('panel-eq', color);
            if(['PAN','VOL'].includes(data.target)) flashPanel('panel-mixer', color);
            if(['ATTACK','DECAY','SUSTAIN','RELEASE'].includes(data.target)) flashPanel('panel-adsr', color);
        });

        socket.on('trigger_note', (data) => {
            if(!isAudioReady || !synth) return;
            synth.triggerAttackRelease(data.note, data.duration);
            spawnVisual(data);
        });

        // --- Helpers ---
        function reflectAllState() {
            updateSynthWave(state.waveform);
            updateEQNodes();
            updateADSRNodes(); updateADSRUI();
            updateMixerNodes(); updateMixerUI();
            updateScaleUI(); updateAutoUI();
            for (const [k, v] of Object.entries(state.params)) { applyParam(k, v); }
            resizeCanvases();
        }

        function updateEQNodes() {
            if(!eqLow) return;
            eqLow.frequency.value = state.eq.low.freq; eqLow.gain.value = state.eq.low.gain;
            eqMid.frequency.value = state.eq.mid.freq; eqMid.gain.value = state.eq.mid.gain;
            eqHigh.frequency.value = state.eq.high.freq; eqHigh.gain.value = state.eq.high.gain;
        }
        function updateADSRNodes() { if(synth) synth.set({ envelope: state.adsr }); }
        function updateADSRUI() {
            document.getElementById('adsr-a').value = state.adsr.attack;
            document.getElementById('adsr-d').value = state.adsr.decay;
            document.getElementById('adsr-s').value = state.adsr.sustain;
            document.getElementById('adsr-r').value = state.adsr.release;
        }
        function updateMixerNodes() { if(synth) synth.volume.value = state.mixer.synth; }
        function updateMixerUI() { document.getElementById('vol-synth').value = state.mixer.synth; }
        function updateScaleUI() {
            document.querySelectorAll('.scale-btn').forEach(b => {
                if(b.dataset.scale === state.scale) b.classList.add('active');
                else b.classList.remove('active');
            });
        }
        function updateAutoUI() {
            const b = document.getElementById('auto-btn');
            if(state.auto.active) { b.textContent="AUTO: ON"; b.classList.add('active'); }
            else { b.textContent="AUTO: OFF"; b.classList.remove('active'); }
            document.getElementById('auto-speed').value = state.auto.speed;
        }

        function applyParam(target, val) {
            if(!synth) return;
            if (target === 'FILTER') {
                // 100Hz - 20000Hz (Exp)
                const freq = 100 * Math.pow(200, val);
                if(globalFilter) globalFilter.frequency.rampTo(freq, 0.1);
            } else if (target === 'PAN') {
                if(panner) panner.pan.rampTo((val*2)-1, 0.1);
            } else if (target === 'VOL') {
                const vol = (val * 60) - 60;
                synth.volume.rampTo(vol, 0.1);
                document.getElementById('vol-synth').value = vol;
            } else if (target === 'REVERB') {
                if(reverb) reverb.wet.rampTo(val, 0.1);
            } else if (['ATTACK','DECAY','SUSTAIN','RELEASE'].includes(target)) {
                if(target==='ATTACK') state.adsr.attack = 0.01 + (val*1.99);
                if(target==='DECAY') state.adsr.decay = 0.1 + (val*1.9);
                if(target==='SUSTAIN') state.adsr.sustain = val;
                if(target==='RELEASE') state.adsr.release = 0.1 + (val*4.9);
                updateADSRNodes();
                updateADSRUI();
                resizeCanvases(); 
            }
        }

        function flashPanelByKey(key, userId) {
            const u = connectedUsers[userId];
            const c = u ? u.color : '#fff';
            if(key==='waveform') flashPanel('panel-wave', c);
            if(key==='eq') flashPanel('panel-eq', c);
            if(key==='mixer' || key==='auto') flashPanel('panel-mixer', c);
            if(key==='adsr') flashPanel('panel-adsr', c);
            if(key==='scale') flashPanel('panel-scale', c);
        }
        function flashPanel(id, color) {
            const p = document.getElementById(id);
            if(p) {
                p.style.borderColor = color; p.style.boxShadow = `0 0 20px ${color}`;
                setTimeout(() => { p.style.borderColor = "#333"; p.style.boxShadow = "0 4px 15px rgba(0,0,0,0.6)"; }, 200);
            }
        }

        function spawnVisual(data) {
            let color = 0x00ffcc;
            if(data.id==='auto') color=0xffaa00;
            else if(connectedUsers[data.id]) color = new THREE.Color(connectedUsers[data.id].color);

            const x = (data.normX - 0.5) * playAreaSize;
            const y = -(data.normY - 0.5) * playAreaSize + playAreaOffsetY;
            
            const mesh = new THREE.Mesh(new THREE.RingGeometry(0.5, 0.6, 32), new THREE.MeshBasicMaterial({ color: color, transparent: true }));
            mesh.position.set(x, y, 0);
            scene.add(mesh);
            visualObjects.push({ mesh, start: Date.now(), dur: data.duration });

            if(prevNotePos && data.id !== 'auto') {
                const geo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(prevNotePos.x, prevNotePos.y, 0), new THREE.Vector3(x,y,0)]);
                const line = new THREE.Line(geo, new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0.3 }));
                scene.add(line);
                visualObjects.push({ mesh: line, start: Date.now(), dur: data.duration*2, type:'line' });
            }
            if(data.id !== 'auto') prevNotePos = {x, y};
        }

        function animate() {
            requestAnimationFrame(animate);
            const now = Date.now();
            const w = document.getElementById('eq-canvas').width;
            const h = document.getElementById('eq-canvas').height;
            const ctx = document.getElementById('eq-canvas').getContext('2d');
            
            ctx.clearRect(0,0,w,h);
            
            // Spectrum
            if(fft) {
                const vals = fft.getValue();
                ctx.fillStyle = 'rgba(0, 255, 204, 0.1)';
                const barW = w / vals.length;
                for(let i=0; i<vals.length; i++) {
                    const v = vals[i]; if(v === -Infinity) continue;
                    const barH = ((v + 100)/100)*h;
                    ctx.fillRect(i*barW, h-barH, barW, barH);
                }
            }
            
            // EQ Curve
            ctx.strokeStyle='#00ffcc'; ctx.lineWidth=2; ctx.beginPath();
            for(let x=0; x<w; x+=3) {
                const f = 20 * Math.pow(1000, x/w);
                let db = 0;
                // Filter Curve Calculation
                const fVal = state.params.FILTER;
                const cutoff = 100 * Math.pow(200, fVal); // Match applyParam logic
                if(cutoff < 19000) db += 20 * Math.log10(1 / Math.sqrt(1 + Math.pow(f/cutoff, 4)));
                
                // Simple EQ bands visual
                if(f < 200) db += state.eq.low.gain;
                else if(f > 4000) db += state.eq.high.gain;
                else db += state.eq.mid.gain;

                const y = h/2 - (db*2);
                if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
            }
            ctx.stroke();

            // 3D Objects
            for(let i=visualObjects.length-1; i>=0; i--) {
                const o = visualObjects[i];
                const p = (now - o.start) / (o.dur * 1000);
                if(p >= 1) { scene.remove(o.mesh); visualObjects.splice(i,1); }
                else {
                    if(o.type !== 'line') {
                        const s = 1 + p * 30;
                        o.mesh.scale.set(s,s,1);
                        o.mesh.material.opacity = 1 - p;
                    } else {
                        o.mesh.material.opacity = (1 - p) * 0.3;
                    }
                }
            }
            renderer.render(scene, camera);
        }
        animate();

        // --- Interaction Logic (Restored!) ---
        const waveCanvas = document.getElementById('wave-canvas');
        const eqCanvas = document.getElementById('eq-canvas');
        const WAVE_SIZE = 128;

        // Waveform Drawing
        let isDrawingWave = false;
        function handleWaveDraw(e) {
            e.preventDefault();
            const rect = waveCanvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const x = (clientX - rect.left) / rect.width;
            const y = -((clientY - rect.top) / rect.height * 2 - 1);
            
            const idx = Math.floor(x * (WAVE_SIZE-1));
            if(idx >= 0 && idx < WAVE_SIZE) {
                state.waveform[idx] = y;
                resizeCanvases();
                updateSynthWave(state.waveform);
                socket.emit('update_waveform', state.waveform); 
            }
        }
        waveCanvas.addEventListener('mousedown', e => { isDrawingWave=true; handleWaveDraw(e); });
        waveCanvas.addEventListener('mousemove', e => { if(isDrawingWave) handleWaveDraw(e); });
        window.addEventListener('mouseup', () => isDrawingWave=false);
        waveCanvas.addEventListener('touchstart', e => { isDrawingWave=true; handleWaveDraw(e); }, {passive:false});
        waveCanvas.addEventListener('touchmove', e => { if(isDrawingWave) handleWaveDraw(e); }, {passive:false});
        window.addEventListener('touchend', () => isDrawingWave=false);

        // EQ Dragging
        let draggingEQ = null;
        function getEQPoint(x, y, rect) {
            if(Math.abs(x - rect.width*0.2) < 30) return 'low';
            if(Math.abs(x - rect.width*0.5) < 30) return 'mid';
            if(Math.abs(x - rect.width*0.8) < 30) return 'high';
            return null;
        }
        function handleEQDrag(e) {
            e.preventDefault();
            const rect = eqCanvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            if(!draggingEQ) {
                draggingEQ = getEQPoint(clientX - rect.left, clientY - rect.top, rect);
            }
            if(draggingEQ) {
                const yVal = -((clientY - rect.top)/rect.height * 24 - 12);
                state.eq[draggingEQ].gain = Math.max(-12, Math.min(12, yVal));
                socket.emit('update_eq', state.eq);
            }
        }
        eqCanvas.addEventListener('mousedown', handleEQDrag);
        window.addEventListener('mousemove', e => { if(draggingEQ) handleEQDrag(e); });
        window.addEventListener('mouseup', () => draggingEQ=null);
        eqCanvas.addEventListener('touchstart', handleEQDrag, {passive:false});
        eqCanvas.addEventListener('touchmove', handleEQDrag, {passive:false});
        window.addEventListener('touchend', () => draggingEQ=null);

        // Background Play (Touch Area)
        function handlePlay(e) {
            if(!isAudioReady) return;
            const target = e.target;
            // メインキャンバスを触った時だけ反応
            if(target.id !== 'main-canvas') return;
            
            e.preventDefault();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const normX = clientX / window.innerWidth;
            const normY = clientY / window.innerHeight;
            
            const scaleNotes = SCALES[state.scale] || SCALES["MINOR_PENTATONIC"];
            const noteIndex = Math.floor((1 - normY) * scaleNotes.length);
            const note = scaleNotes[Math.min(noteIndex, scaleNotes.length - 1)];
            
            socket.emit('play_note', { note, duration: 0.5 + normX * 2.0, normX, normY });
        }
        window.addEventListener('mousedown', handlePlay);
        window.addEventListener('touchstart', handlePlay, {passive:false});

        // --- Helpers ---
        function resizeCanvases() {
            const wCanvas = document.getElementById('wave-canvas');
            const wCtx = wCanvas.getContext('2d');
            wCtx.clearRect(0,0,240,90);
            wCtx.strokeStyle='#00ffcc'; wCtx.beginPath();
            const wave = state.waveform;
            for(let i=0; i<wave.length; i++) {
                const x = (i/128)*240; const y = 45 - (wave[i]*40);
                if(i===0) wCtx.moveTo(x,y); else wCtx.lineTo(x,y);
            }
            wCtx.stroke();

            const aCanvas = document.getElementById('adsr-canvas');
            const aCtx = aCanvas.getContext('2d');
            aCtx.clearRect(0,0,240,70);
            aCtx.strokeStyle='#00ffcc'; aCtx.lineWidth=2; aCtx.beginPath();
            const A = state.adsr.attack * 40; 
            const D = state.adsr.decay * 40;
            const S = (1 - state.adsr.sustain) * 70;
            const R = state.adsr.release * 40;
            aCtx.moveTo(0, 70);
            aCtx.lineTo(A, 0); aCtx.lineTo(A+D, S);
            aCtx.lineTo(A+D+30, S); aCtx.lineTo(A+D+30+R, 70);
            aCtx.stroke();
        }

        function updateSynthWave(buffer) {
            if(!synth) return;
            const partials = [];
            for(let k=1; k<=16; k++) partials.push(1/k); 
            synth.set({oscillator:{partials:partials}});
        }

        function updateLayout() {
            const h = window.innerHeight;
            const ctrlH = document.getElementById('controls').offsetHeight;
            playAreaSize = Math.min(window.innerWidth, h - ctrlH) * 0.9;
            playAreaOffsetY = ctrlH / 2;
            camera.left = window.innerWidth / -2; camera.right = window.innerWidth / 2;
            camera.top = h / 2; camera.bottom = h / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, h);
        }
        window.addEventListener('resize', updateLayout);

        // UI Listeners
        document.getElementById('reset-btn').onclick = () => {
             const newWave = new Array(128).fill(0).map((_, i) => Math.sin((i/128)*Math.PI*2));
             socket.emit('update_waveform', newWave);
        };
        document.getElementById('auto-btn').onclick = () => {
            const next = !state.auto.active;
            socket.emit('update_auto', { active: next, speed: state.auto.speed });
        };
        ['a','d','s','r'].forEach(k => {
            document.getElementById('adsr-'+k).addEventListener('input', (e) => {
                state.adsr[{a:'attack',d:'decay',s:'sustain',r:'release'}[k]] = parseFloat(e.target.value);
                resizeCanvases();
                socket.emit('update_adsr', state.adsr);
            });
        });
        document.getElementById('vol-synth').addEventListener('input', (e) => {
            state.mixer.synth = parseFloat(e.target.value);
            if(synth) synth.volume.value = state.mixer.synth;
            socket.emit('update_mixer', state.mixer);
        });
        document.querySelectorAll('.scale-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                socket.emit('update_scale', btn.dataset.scale);
            });
        });

        // Sensor
        const sensorBtn = document.getElementById('sensor-btn');
        let sensorActive = false;
        let sensorTargets = {x:'FILTER', y:'REVERB'};
        let lastSensorSend = 0;

        document.getElementById('target-x-btn').onclick = function() {
            const opts=['FILTER','PAN','VOL','ATTACK','DECAY'];
            sensorTargets.x = opts[(opts.indexOf(sensorTargets.x)+1)%opts.length];
            this.textContent = sensorTargets.x;
        };
        document.getElementById('target-y-btn').onclick = function() {
            const opts=['REVERB','RELEASE','SUSTAIN'];
            sensorTargets.y = opts[(opts.indexOf(sensorTargets.y)+1)%opts.length];
            this.textContent = sensorTargets.y;
        };

        sensorBtn.onclick = async () => {
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                const p = await DeviceOrientationEvent.requestPermission();
                if(p!=='granted') return;
            }
            sensorActive = !sensorActive;
            sensorBtn.className = sensorActive ? 'active' : '';
            sensorBtn.textContent = sensorActive ? 'SENSOR: ON' : 'SENSOR: OFF';
            if(sensorActive) window.addEventListener('deviceorientation', onSensor);
            else window.removeEventListener('deviceorientation', onSensor);
        };

        function onSensor(e) {
            const gx = Math.min(1, Math.max(-1, (e.gamma||0)/45));
            const gy = Math.min(1, Math.max(-1, ((e.beta||0)-45)/45));
            
            const vx = (gx+1)/2; 
            const vy = 1 - ((gy+1)/2); 

            document.getElementById('fill-x').style.height = (vx*100)+'%';
            document.getElementById('fill-y').style.height = (vy*100)+'%';

            applyParam(sensorTargets.x, vx);
            applyParam(sensorTargets.y, vy);

            const now = Date.now();
            if(now - lastSensorSend > 80) {
                socket.emit('update_param', { target: sensorTargets.x, value: vx });
                socket.emit('update_param', { target: sensorTargets.y, value: vy });
                lastSensorSend = now;
            }
        }
    </script>
</body>
</html>
