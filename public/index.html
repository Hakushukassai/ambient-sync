<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Synth Master Sync</title>
    <style>
        body { margin: 0; overflow: hidden; background: #080808; touch-action: none; color: white; font-family: monospace; }
        
        /* 起動ボタン (必須) */
        #start-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 9999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            cursor: pointer;
        }
        #start-btn {
            background: transparent; border: 2px solid #00ffcc; color: #00ffcc;
            padding: 15px 40px; font-size: 18px; letter-spacing: 4px;
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.4);
            animation: pulse 2s infinite; cursor: pointer;
        }
        @keyframes pulse { 0% { opacity: 0.8; } 50% { opacity: 1; box-shadow: 0 0 40px rgba(0, 255, 204, 0.8); } 100% { opacity: 0.8; } }

        #controls {
            position: fixed; bottom: 0; left: 0; width: 100%; height: 280px; 
            background: linear-gradient(transparent, rgba(0,0,0,0.95) 15%);
            display: flex; flex-direction: row; justify-content: center; align-items: center;
            padding-bottom: 20px; z-index: 50; gap: 15px; box-sizing: border-box;
            overflow-x: auto; /* スマホでスクロール可能に */
        }
        #controls::-webkit-scrollbar { display: none; } 

        .panel-section {
            display: flex; flex-direction: column; align-items: center;
            background: rgba(10, 10, 10, 0.85); border: 1px solid #333; border-radius: 6px;
            padding: 10px; backdrop-filter: blur(10px); width: 260px; height: 210px;
            justify-content: flex-start; box-shadow: 0 4px 15px rgba(0,0,0,0.6);
            flex-shrink: 0; position: relative; transition: border-color 0.1s, box-shadow 0.1s;
        }
        .label { font-size: 11px; color: #00ffcc; margin-bottom: 8px; letter-spacing: 2px; font-weight: bold; pointer-events: none; }

        canvas { background: rgba(0, 0, 0, 0.5); border: 1px solid #444; border-radius: 4px; }
        
        .eq-values { font-size: 10px; color: #888; width: 100%; text-align: center; margin-top: 5px; }
        .mixer-container { display: flex; gap: 30px; height: 100%; align-items: center; justify-content: center; }
        #adsr-container { display: flex; flex-direction: column; align-items: center; width: 100%; }
        .sliders { display: flex; gap: 10px; width: 100%; justify-content: space-between; margin-top: 5px; }
        .slider-group { display: flex; flex-direction: column; align-items: center; }
        
        input[type=range].vertical {
            -webkit-appearance: slider-vertical; width: 20px; height: 90px;
            cursor: pointer; 
        }
        .param-label { font-size: 10px; color: #666; margin-top: 6px; font-weight: bold; }

        .btn-group { display: flex; gap: 10px; margin-top: 10px; }
        button.ctrl-btn {
            background: rgba(0,0,0,0.6); border: 1px solid #333; color: #00ffcc;
            font-size: 10px; padding: 6px 14px; cursor: pointer; border-radius: 2px;
        }
        button.ctrl-btn.active { background: #00ffcc; color: #000; font-weight: bold; }

        .scale-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; width: 100%; margin-top: 5px; height: 100%; overflow-y: auto; }
        .scale-btn { padding: 8px 4px; font-size: 9px; text-align: left; border: 1px solid #333; background: rgba(0,0,0,0.3); color: #aaa; cursor: pointer;}
        .scale-btn.active { border-color: #00ffcc; background: rgba(0,255,204,0.2); color: white; }

        #status-bar {
            position: fixed; top: 20px; left: 20px; z-index: 100;
            display: flex; gap: 10px; align-items: center; font-size: 10px; color: #888;
        }
        .my-color-dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-left: 5px; border: 1px solid #fff; }

        #sensor-btn {
            position: fixed; top: 20px; right: 20px; z-index: 100;
            background: rgba(0,0,0,0.5); border: 1px solid #444; color: #888;
            padding: 8px 12px; font-size: 10px; border-radius: 20px; cursor: pointer;
        }
        #sensor-btn.active { border-color: #00ffcc; color: #00ffcc; background: rgba(0,255,204,0.1); }

        #sensor-panel {
            position: fixed; top: 60px; right: 20px; z-index: 90; display: flex; gap: 12px;
        }
        .sensor-group { display: flex; flex-direction: column; align-items: center; gap: 5px; }
        .sensor-meter {
            width: 10px; height: 80px; background: rgba(255,255,255,0.1);
            border-radius: 4px; position: relative; overflow: hidden;
            display: flex; flex-direction: column-reverse; border: 1px solid #333;
        }
        .sensor-fill { width: 100%; height: 50%; background: #00ffcc; transition: height 0.1s; }
        .target-btn {
            font-size: 9px; color: #00ffcc; background: rgba(0,0,0,0.6);
            border: 1px solid #444; padding: 4px; width: 45px; text-align: center; cursor: pointer;
        }
    </style>
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    
    <div id="start-overlay">
        <button id="start-btn">POWER ON</button>
        <div style="color:#666; font-size:10px; margin-top:10px;">TURN UP YOUR VOLUME</div>
    </div>

    <div id="status-bar">
        <span id="user-count">OFFLINE</span>
        <span>YOU: <span id="my-color" class="my-color-dot"></span></span>
    </div>

    <button id="sensor-btn">SENSOR: OFF</button>
    
    <div id="sensor-panel">
        <div class="sensor-group">
            <div class="sensor-meter"><div class="sensor-fill" id="fill-x"></div></div>
            <button class="target-btn" id="target-x-btn">FILTER</button>
        </div>
        <div class="sensor-group">
            <div class="sensor-meter"><div class="sensor-fill" id="fill-y" style="background:#ff00cc; box-shadow: 0 0 10px #ff00cc;"></div></div>
            <button class="target-btn" id="target-y-btn">REVERB</button>
        </div>
    </div>

    <div id="controls">
        <div class="panel-section" id="panel-wave">
            <div class="label">1. WAVEFORM</div>
            <canvas id="wave-canvas" width="240" height="90"></canvas>
            <div class="btn-group">
                <button class="ctrl-btn" id="reset-btn">RESET</button>
                <button class="ctrl-btn" id="auto-btn">AUTO: OFF</button>
            </div>
        </div>

        <div class="panel-section" id="panel-eq">
            <div class="label">2. EQ & SPECTRUM</div>
            <div id="eq-container">
                <canvas id="eq-canvas" width="240" height="100"></canvas>
                <div class="eq-values" id="eq-readout">DRAG POINTS</div>
            </div>
        </div>

        <div class="panel-section" id="panel-mixer">
            <div class="label">3. MIXER & AUTO</div>
            <div class="mixer-container">
                <div class="slider-group"><input type="range" class="vertical" id="vol-synth" min="-60" max="0" step="1" value="-6"><span class="param-label">VOL</span></div>
                <div class="slider-group"><input type="range" class="vertical" id="auto-speed" min="0" max="100" step="1" value="30"><span class="param-label">FREQ</span></div>
            </div>
        </div>

        <div class="panel-section" id="panel-adsr">
            <div class="label">4. ENVELOPE</div>
            <div id="adsr-container">
                <canvas id="adsr-canvas" width="240" height="70"></canvas>
                <div class="sliders">
                    <div class="slider-group"><input type="range" class="vertical" id="adsr-a" min="0.01" max="2.0" step="0.01" value="0.05"><span class="param-label">A</span></div>
                    <div class="slider-group"><input type="range" class="vertical" id="adsr-d" min="0.1" max="2.0" step="0.01" value="0.2"><span class="param-label">D</span></div>
                    <div class="slider-group"><input type="range" class="vertical" id="adsr-s" min="0" max="1.0" step="0.01" value="0.5"><span class="param-label">S</span></div>
                    <div class="slider-group"><input type="range" class="vertical" id="adsr-r" min="0.1" max="5.0" step="0.1" value="1.0"><span class="param-label">R</span></div>
                </div>
            </div>
        </div>

        <div class="panel-section" id="panel-scale">
            <div class="label">5. SCALE (MOOD)</div>
            <div class="scale-grid">
                <button class="scale-btn active" data-scale="MINOR_PENTATONIC">MINOR PENTATONIC</button>
                <button class="scale-btn" data-scale="MAJOR">MAJOR</button>
                <button class="scale-btn" data-scale="MINOR">MINOR</button>
                <button class="scale-btn" data-scale="DORIAN">DORIAN</button>
                <button class="scale-btn" data-scale="LYDIAN">LYDIAN</button>
                <button class="scale-btn" data-scale="RYUKYU">RYUKYU</button>
                <button class="scale-btn" data-scale="MIYAKOBUSHI">MIYAKOBUSHI</button>
                <button class="scale-btn" data-scale="WHOLE_TONE">WHOLE TONE</button>
            </div>
        </div>
    </div>

    <script>
        const socket = io();
        let isAudioReady = false;
        let myId = null;
        let connectedUsers = {};
        
        // データ保持用 (Default values)
        let state = {
            waveform: new Array(128).fill(0),
            eq: { low: {freq:100, gain:0}, mid: {freq:1000, gain:0}, high: {freq:5000, gain:0} },
            mixer: { synth: -6 },
            adsr: { attack: 0.05, decay: 0.2, sustain: 0.5, release: 1.0 },
            params: { 'FILTER': 0.5, 'PAN': 0.5, 'VOL': 0.8, 'REVERB': 0.0 },
            auto: { active: false, speed: 30 },
            scale: "MINOR_PENTATONIC"
        };

        // Audio Objects
        let synth, limiter, chorus, reverb, fft, panner, globalFilter;
        let eqLow, eqMid, eqHigh;

        // Visuals
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 1, 1000);
        camera.position.z = 10;
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.domElement.id = 'main-canvas';
        document.body.appendChild(renderer.domElement);
        
        // 3D Objects Store
        const visualObjects = [];
        let playAreaOffsetY = 0;
        let prevNotePos = null;

        // --- 初期化フロー ---
        document.getElementById('start-btn').addEventListener('click', async () => {
            if(isAudioReady) return;
            await Tone.start();
            initAudioEngine();
            document.getElementById('start-overlay').style.display = 'none';
            isAudioReady = true;
        });

        function initAudioEngine() {
            fft = new Tone.Analyser("fft", 256);
            fft.smoothing = 0.85;
            limiter = new Tone.Limiter(-1).connect(fft);
            fft.toDestination();

            chorus = new Tone.Chorus(4, 2.5, 0.5);
            reverb = new Tone.Reverb({ decay: 5, wet: state.params.REVERB });
            globalFilter = new Tone.Filter(20000, "lowpass", -12);
            panner = new Tone.Panner(0);

            eqLow = new Tone.Filter({ type: "lowshelf", frequency: state.eq.low.freq, gain: state.eq.low.gain });
            eqMid = new Tone.Filter({ type: "peaking", frequency: state.eq.mid.freq, gain: state.eq.mid.gain, Q: 2.5 });
            eqHigh = new Tone.Filter({ type: "highshelf", frequency: state.eq.high.freq, gain: state.eq.high.gain });

            reverb.connect(limiter);
            chorus.connect(reverb);
            globalFilter.connect(chorus);
            eqHigh.connect(globalFilter);
            eqMid.connect(eqHigh);
            eqLow.connect(eqMid);
            panner.connect(eqLow);

            synth = new Tone.PolySynth(Tone.Synth, {
                maxPolyphony: 20,
                volume: state.mixer.synth,
                oscillator: { type: "triangle" },
                envelope: state.adsr
            }).connect(panner);

            updateSynthWave(state.waveform);
            updateLayout();
            resizeCanvases(); // 初回描画
        }

        // --- Socket Handling ---
        socket.on('init_state', (data) => {
            myId = data.id;
            document.getElementById('my-color').style.backgroundColor = data.color;
            // データ同期
            if(data.state) {
                state = data.state;
                reflectAllState(); // 全UI・音声を更新
            }
            if(data.users) connectedUsers = data.users;
        });

        socket.on('update_users', (users) => {
            connectedUsers = users;
            document.getElementById('user-count').textContent = `ONLINE: ${Object.keys(users).length}`;
        });

        socket.on('sync_state_part', (data) => {
            state[data.key] = data.value;
            // 変更があった部分だけ反映
            if(data.key === 'waveform') { updateSynthWave(data.value); resizeCanvases(); }
            if(data.key === 'eq') { updateEQNodes(); resizeCanvases(); }
            if(data.key === 'adsr') { updateADSRNodes(); updateADSRUI(); resizeCanvases(); }
            if(data.key === 'mixer') { updateMixerNodes(); updateMixerUI(); }
            if(data.key === 'scale') { updateScaleUI(); }
            if(data.key === 'auto') { updateAutoUI(); }
            
            flashPanelByKey(data.key, data.userId);
        });

        socket.on('sync_param', (data) => {
            // パラメータ個別更新
            state.params[data.target] = data.value;
            applyParam(data.target, data.value);
            
            // 関連パネルを光らせる
            const user = connectedUsers[data.userId];
            const color = user ? user.color : '#fff';
            
            if(['FILTER','REVERB'].includes(data.target)) flashPanel('panel-eq', color);
            if(['PAN','VOL'].includes(data.target)) flashPanel('panel-mixer', color);
            if(['ATTACK','DECAY','SUSTAIN','RELEASE'].includes(data.target)) flashPanel('panel-adsr', color);
        });

        socket.on('trigger_note', (data) => {
            if(!synth) return;
            synth.triggerAttackRelease(data.note, data.duration);
            spawnVisual(data);
        });

        // --- Reflect State to Audio & UI ---
        function reflectAllState() {
            updateSynthWave(state.waveform);
            updateEQNodes();
            updateADSRNodes(); updateADSRUI();
            updateMixerNodes(); updateMixerUI();
            updateScaleUI();
            updateAutoUI();
            for (const [k, v] of Object.entries(state.params)) { applyParam(k, v); }
            resizeCanvases();
        }

        function updateEQNodes() {
            if(!eqLow) return;
            eqLow.frequency.value = state.eq.low.freq; eqLow.gain.value = state.eq.low.gain;
            eqMid.frequency.value = state.eq.mid.freq; eqMid.gain.value = state.eq.mid.gain;
            eqHigh.frequency.value = state.eq.high.freq; eqHigh.gain.value = state.eq.high.gain;
        }
        function updateADSRNodes() { if(synth) synth.set({ envelope: state.adsr }); }
        function updateADSRUI() {
            document.getElementById('adsr-a').value = state.adsr.attack;
            document.getElementById('adsr-d').value = state.adsr.decay;
            document.getElementById('adsr-s').value = state.adsr.sustain;
            document.getElementById('adsr-r').value = state.adsr.release;
        }
        function updateMixerNodes() { if(synth) synth.volume.value = state.mixer.synth; }
        function updateMixerUI() { document.getElementById('vol-synth').value = state.mixer.synth; }
        function updateScaleUI() {
            document.querySelectorAll('.scale-btn').forEach(b => {
                if(b.dataset.scale === state.scale) b.classList.add('active');
                else b.classList.remove('active');
            });
        }
        function updateAutoUI() {
            const b = document.getElementById('auto-btn');
            if(state.auto.active) { b.textContent="AUTO: ON"; b.classList.add('active'); }
            else { b.textContent="AUTO: OFF"; b.classList.remove('active'); }
            document.getElementById('auto-speed').value = state.auto.speed;
        }

        // --- Param Mapping ---
        function applyParam(target, val) {
            if(!synth) return;
            if (target === 'FILTER') {
                const freq = 100 * Math.pow(80, val);
                if(globalFilter) globalFilter.frequency.rampTo(freq, 0.1);
            } else if (target === 'PAN') {
                if(panner) panner.pan.rampTo((val*2)-1, 0.1);
            } else if (target === 'VOL') {
                const vol = (val * 60) - 60;
                synth.volume.rampTo(vol, 0.1);
                document.getElementById('vol-synth').value = vol;
            } else if (target === 'REVERB') {
                if(reverb) reverb.wet.rampTo(val, 0.1);
            } else if (['ATTACK','DECAY','SUSTAIN','RELEASE'].includes(target)) {
                // ADSR更新は state.adsr も更新する
                if(target==='ATTACK') state.adsr.attack = 0.01 + (val*1.99);
                if(target==='DECAY') state.adsr.decay = 0.1 + (val*1.9);
                if(target==='SUSTAIN') state.adsr.sustain = val;
                if(target==='RELEASE') state.adsr.release = 0.1 + (val*4.9);
                updateADSRNodes();
                updateADSRUI();
                resizeCanvases(); // グラフ再描画
            }
        }

        // --- Visual Helpers ---
        function flashPanel(id, color) {
            const p = document.getElementById(id);
            if(p) {
                p.style.borderColor = color; p.style.boxShadow = `0 0 20px ${color}`;
                setTimeout(() => { p.style.borderColor = "#333"; p.style.boxShadow = "0 4px 15px rgba(0,0,0,0.6)"; }, 200);
            }
        }
        function flashPanelByKey(key, userId) {
            const u = connectedUsers[userId];
            const c = u ? u.color : '#fff';
            if(key==='waveform') flashPanel('panel-wave', c);
            if(key==='eq') flashPanel('panel-eq', c);
            if(key==='mixer' || key==='auto') flashPanel('panel-mixer', c);
            if(key==='adsr') flashPanel('panel-adsr', c);
            if(key==='scale') flashPanel('panel-scale', c);
        }

        function spawnVisual(data) {
            let color = 0x00ffcc;
            if(data.id==='auto') color=0xffaa00;
            else if(connectedUsers[data.id]) color = new THREE.Color(connectedUsers[data.id].color);

            const x = (data.normX - 0.5) * playAreaSize;
            const y = -(data.normY - 0.5) * playAreaSize + playAreaOffsetY;
            
            const mesh = new THREE.Mesh(new THREE.RingGeometry(0.5, 0.6, 32), new THREE.MeshBasicMaterial({ color: color, transparent: true }));
            mesh.position.set(x, y, 0);
            scene.add(mesh);
            visualObjects.push({ mesh, start: Date.now(), dur: data.duration });

            if(prevNotePos && data.id !== 'auto') {
                const geo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(prevNotePos.x, prevNotePos.y, 0), new THREE.Vector3(x,y,0)]);
                const line = new THREE.Line(geo, new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0.3 }));
                scene.add(line);
                visualObjects.push({ mesh: line, start: Date.now(), dur: data.duration*2, type:'line' });
            }
            if(data.id !== 'auto') prevNotePos = {x, y};
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const now = Date.now();
            
            // Draw EQ/Spec
            const eqCanvas = document.getElementById('eq-canvas');
            if(eqCanvas) {
                const ctx = eqCanvas.getContext('2d');
                const w = eqCanvas.width; const h = eqCanvas.height;
                ctx.clearRect(0,0,w,h);
                
                // Spectrum
                if(fft) {
                    const vals = fft.getValue();
                    ctx.fillStyle = 'rgba(0, 255, 204, 0.1)';
                    const barW = w / vals.length;
                    for(let i=0; i<vals.length; i++) {
                        const v = vals[i]; if(v === -Infinity) continue;
                        const barH = ((v + 100)/100)*h;
                        ctx.fillRect(i*barW, h-barH, barW, barH);
                    }
                }
                
                // EQ Curve
                ctx.strokeStyle='#00ffcc'; ctx.lineWidth=2; ctx.beginPath();
                for(let x=0; x<w; x+=3) {
                    const f = 20 * Math.pow(1000, x/w); // Log scale approx
                    let db = 0;
                    // LPF influence
                    const fVal = state.params.FILTER;
                    const cutoff = 100 * Math.pow(80, fVal);
                    if(cutoff < 19000) db += 20 * Math.log10(1 / Math.sqrt(1 + Math.pow(f/cutoff, 4)));
                    
                    // EQ Bands influence
                    // (Simplified calculation for visualization)
                    if(f < 200) db += state.eq.low.gain;
                    else if(f > 4000) db += state.eq.high.gain;
                    else db += state.eq.mid.gain; // very rough approx

                    const y = h/2 - (db*2);
                    if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
                }
                ctx.stroke();
            }

            // Three.js Visuals
            for(let i=visualObjects.length-1; i>=0; i--) {
                const o = visualObjects[i];
                const p = (now - o.start) / (o.dur * 1000);
                if(p >= 1) {
                    scene.remove(o.mesh); visualObjects.splice(i,1);
                } else {
                    if(o.type !== 'line') {
                        const s = 1 + p * 30;
                        o.mesh.scale.set(s,s,1);
                        o.mesh.material.opacity = 1 - p;
                    } else {
                        o.mesh.material.opacity = (1 - p) * 0.3;
                    }
                }
            }
            renderer.render(scene, camera);
        }
        animate();

        // --- Canvas Resizers ---
        function resizeCanvases() {
            const wCanvas = document.getElementById('wave-canvas');
            const wCtx = wCanvas.getContext('2d');
            wCtx.clearRect(0,0,240,90);
            wCtx.strokeStyle='#00ffcc'; wCtx.beginPath();
            const wave = state.waveform;
            for(let i=0; i<wave.length; i++) {
                const x = (i/128)*240; const y = 45 - (wave[i]*40);
                if(i===0) wCtx.moveTo(x,y); else wCtx.lineTo(x,y);
            }
            wCtx.stroke();

            // ADSR
            const aCanvas = document.getElementById('adsr-canvas');
            const aCtx = aCanvas.getContext('2d');
            aCtx.clearRect(0,0,240,70);
            aCtx.strokeStyle='#00ffcc'; aCtx.lineWidth=2; aCtx.beginPath();
            const A = state.adsr.attack * 40; 
            const D = state.adsr.decay * 40;
            const S = (1 - state.adsr.sustain) * 70;
            const R = state.adsr.release * 40;
            
            aCtx.moveTo(0, 70);
            aCtx.lineTo(A, 0);
            aCtx.lineTo(A+D, S);
            aCtx.lineTo(A+D+30, S); // Sustain hold
            aCtx.lineTo(A+D+30+R, 70);
            aCtx.stroke();
        }

        function updateSynthWave(buffer) {
            if(!synth) return;
            // partials update logic simplified
            const partials = [];
            for (let k = 1; k <= 16; k++) partials.push(1/k); // Dummy update to prevent crash if complex math fails
            synth.set({oscillator:{partials:partials}});
        }

        // --- Interaction & Sensor ---
        function updateLayout() {
            const h = window.innerHeight;
            const ctrlH = document.getElementById('controls').offsetHeight;
            playAreaSize = Math.min(window.innerWidth, h - ctrlH) * 0.9;
            playAreaOffsetY = ctrlH / 2;
            const aspect = window.innerWidth / h;
            const frustumSize = Math.max(window.innerWidth, h);
            camera.left = window.innerWidth / -2; camera.right = window.innerWidth / 2;
            camera.top = h / 2; camera.bottom = h / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, h);
        }
        window.addEventListener('resize', updateLayout);

        // Input
        let lastMove = 0;
        function handleInput(x, y) {
            if(!isAudioReady) return;
            const now = Date.now();
            if(now - lastMove > 100) {
                const notes = SCALES[state.scale] || SCALES["MINOR_PENTATONIC"];
                const idx = Math.floor((1-y) * notes.length);
                const note = notes[Math.min(idx, notes.length-1)] || "C4";
                socket.emit('play_note', { note, duration: 0.5 + x*2, normX:x, normY:y });
                lastMove = now;
            }
        }
        window.addEventListener('mousemove', e => {
            if(e.buttons===1 && e.target.tagName==='CANVAS' && e.target.id==='main-canvas') {
                const rect = renderer.domElement.getBoundingClientRect();
                // 簡易計算
                handleInput(e.clientX/window.innerWidth, e.clientY/window.innerHeight);
            }
        });
        window.addEventListener('touchmove', e => {
            if(e.target.tagName==='CANVAS' && e.target.id==='main-canvas') {
                e.preventDefault();
                const t = e.touches[0];
                handleInput(t.clientX/window.innerWidth, t.clientY/window.innerHeight);
            }
        }, {passive:false});

        // UI Event Listeners
        document.getElementById('reset-btn').onclick = () => {
             const newWave = new Array(128).fill(0).map((_, i) => Math.sin((i/128)*Math.PI*2));
             socket.emit('update_waveform', newWave);
        };
        document.getElementById('auto-btn').onclick = () => {
            const next = !state.auto.active;
            socket.emit('update_auto', { active: next, speed: state.auto.speed });
        };
        
        // ADSR Inputs
        ['a','d','s','r'].forEach(k => {
            const el = document.getElementById('adsr-'+k);
            el.addEventListener('input', () => {
                const val = parseFloat(el.value);
                state.adsr[{a:'attack',d:'decay',s:'sustain',r:'release'}[k]] = val;
                resizeCanvases();
                socket.emit('update_adsr', state.adsr);
            });
        });

        // Sensor
        const sensorBtn = document.getElementById('sensor-btn');
        let sensorActive = false;
        let sensorTargets = {x:'FILTER', y:'REVERB'};
        let lastSensorSend = 0;

        document.getElementById('target-x-btn').onclick = function() {
            const opts=['FILTER','PAN','VOL','ATTACK','DECAY'];
            sensorTargets.x = opts[(opts.indexOf(sensorTargets.x)+1)%opts.length];
            this.textContent = sensorTargets.x;
        };
        document.getElementById('target-y-btn').onclick = function() {
            const opts=['REVERB','RELEASE','SUSTAIN'];
            sensorTargets.y = opts[(opts.indexOf(sensorTargets.y)+1)%opts.length];
            this.textContent = sensorTargets.y;
        };

        sensorBtn.onclick = async () => {
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                const p = await DeviceOrientationEvent.requestPermission();
                if(p!=='granted') return;
            }
            sensorActive = !sensorActive;
            sensorBtn.className = sensorActive ? 'active' : '';
            sensorBtn.textContent = sensorActive ? 'SENSOR: ON' : 'SENSOR: OFF';
            if(sensorActive) window.addEventListener('deviceorientation', onSensor);
            else window.removeEventListener('deviceorientation', onSensor);
        };

        function onSensor(e) {
            const gx = Math.min(1, Math.max(-1, (e.gamma||0)/45));
            const gy = Math.min(1, Math.max(-1, ((e.beta||0)-45)/45));
            
            const vx = (gx+1)/2; 
            const vy = 1 - ((gy+1)/2); // invert Y

            document.getElementById('fill-x').style.height = (vx*100)+'%';
            document.getElementById('fill-y').style.height = (vy*100)+'%';

            // Local Apply
            applyParam(sensorTargets.x, vx);
            applyParam(sensorTargets.y, vy);

            // Network Send (throttled)
            const now = Date.now();
            if(now - lastSensorSend > 80) {
                socket.emit('update_param', { target: sensorTargets.x, value: vx });
                socket.emit('update_param', { target: sensorTargets.y, value: vy });
                lastSensorSend = now;
            }
        }
    </script>
</body>
</html>
